-battery_condition
)
# Dummy encode
data <- cbc_encode(
data,
coding = 'dummy',
ref_levels = list(battery_refurbish = 'original')
) %>%
as.data.frame() %>%
clean_names()
# Estimate MNL model
# First create some dummy coded variables for categorical variables
#data <- dummy_cols(data, c('battery_refurbish', 'degradation_high'))
# Clean up names of created variables
glimpse(data)
# Estimate the model
model1 <- logitr(
data = data,
outcome = "choice",
obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
#### ranges are highly correlated, so only include one year.
#### Keeping year8 generates higher R2
# "battery_range_year3",
"battery_range_year8",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
<<<<<<< HEAD
=======
head(choice_data)
# Remove bad respID
choice_data <- choice_data %>%
filter(respID != 3587)
data <- data %>%
filter(respID != 3587)
# Create new values for respID & obsID
nRespondents <- nrow(data)
nAlts <- max(survey$altID)
nQuestions <- max(survey$qID)
choice_data$respID <- rep(seq(nRespondents), each = nAlts * nQuestions)
choice_data$obsID <- rep(seq(nRespondents * nQuestions), each = nAlts)
# Reorder columns - it's nice to have the "ID" variables first
choice_data <- choice_data %>%
select(ends_with("ID"), "choice", everything())
head(choice_data)
# Save cleaned data for modeling
write_csv(
choice_data,
here(
"code files",
"pilot",
"data",
"vehicle_choice_data.csv"
>>>>>>> Stashed changes
)
)
source(here::here('code', 'setup.R'))
data <- read_csv(here(
"data",
"pilot",
"survey_data.csv"
))
source(here::here('code', 'setup.R'))
data <- read_csv(here(
"data",
"pilot",
"survey_data.csv"
))
data <- read_csv(here(
"data",
"pilot",
"survey_data.csv"
))
data <- data %>%
mutate(
age_num = 2025 - birth_year,
gender_cate = case_when(
gender == "prefer_not_answer" ~ "prefer_not_answer",
gender %notin% c("male", "female") ~ "other",
T ~ gender
),
ethnicity_cate = case_when(
ethnicity == "no" ~ "non-hispanic",
T ~ "hispanic"
),
race_cate = case_when(
race == "white" ~ "white_only",
race == "african_american" ~ "african_american_only",
T ~ "other"
),
education_cate = case_when(
education == "prefer_not_answer" ~ "prefer_not_answer",
education %in% c("below_high_school", "high_school") ~ "high_school",
education %in%
c("college_less", "college_more", "technical") ~ "some_college",
education %in% c("bachelor", "Postgraduate courses") ~ "bachelor",
T ~ "graduate"
),
student_cate = case_when(
str_detect(employment, "student") ~ "student",
employment == "prefer_not_answer" ~ "prefer_not_answer",
T ~ "non-student"
),
employment_cate = case_when(
employment == "prefer_not_answer" ~ "prefer_not_answer",
str_detect(employment, "full_time") ~ "full_time",
str_detect(employment, "part_time") ~ "part_time",
T ~ "not_employed"
),
hhincome_num = as.numeric(hh_income),
hhsize_num = case_when(
hh_size == "more_than_5" ~ 6,
T ~ as.numeric(hh_size)
),
hhtenure_cate = case_when(
housing_tenure %in% c("own", "rent") ~ housing_tenure,
housing_tenure == "do_not_know" ~ "prefer_not_answer",
T ~ "other"
),
hhtype_cate = case_when(
housing_type %in% c("sf_detached", "sf_attached") ~ housing_type,
str_detect(housing_type, "apart") ~ "apart",
T ~ "other"
)
) %>%
mutate(final_weights = 1)
# ----Attitudes----
## ----BEV (factor analysis)----
### Explortory Factor analysis
### (http://www.di.fc.ul.pt/~jpn/r/factoranalysis/factoranalysis.html)
att <- data %>%
# filter(attitudes_2_a_attention_check_agree=="strongly_agree")%>%
select(!attitudes_2_a_attention_check_agree) %>%
select(
session_id,
attitudes_1_a_ev_norm:attitudes_2_a_ev_battery_function,
-(contains("battery"))
) %>%
mutate(across(
starts_with("attitudes_"),
~ case_match(
.,
"strongly_disagree" ~ 1,
"somewhat_disagree" ~ 2,
"neutral" ~ 3,
"somewhat_agree" ~ 4,
"strongly_agree" ~ 5,
.default = NA_integer_
)
))
# summary(att)
att <- as.data.frame(att[complete.cases(att), ])
fit <- factanal(
att[, c(2:ncol(att))],
2,
rotation = "promax",
score = "Bartlett"
)
l <- fit$loadings
# l<-fit_oblimin$loadings
l.table <- data.frame(matrix(
as.numeric(l),
attributes(l)$dim,
dimnames = attributes(l)$dimnames
))
l.table <- cbind(row.names(l.table), l.table)
######### Factor Loading
scores <- data.frame(fit$scores)
att_a_FC <- cbind(att, scores) %>%
select(session_id, Factor1, Factor2)
colnames(att_a_FC) <- c("session_id", "FA_EV_benefit", "FA_EV_anxiety")
data$FA_EV_benefit <- NULL
data$FA_EV_anxiety <- NULL
data <- data %>%
merge(att_a_FC, by = "session_id", all.x = T)
## ----Other----
data <- data %>%
mutate(
ATT_EVB_environment = attitudes_2_a_ev_battery_environment,
ATT_EVB_function = attitudes_2_a_ev_battery_function,
ATT_techsavvy = attitudes_2_b_tech_savvy,
ATT_risktaker = attitudes_2_b_risk_taker,
ATT_climate = climate_change,
ATT_political = political_view,
ATT_voting = party_voting
)
# ----Knowledge----
data <- data %>%
mutate(
knowledge_gas = case_when(
run_on_gasoline == "hev, phev" ~ 2,
str_detect(run_on_gasoline, "hev") |
str_detect(run_on_gasoline, "phev") ~ 1,
T ~ 0
),
knowledge_plugin = case_when(
plugged_in == "phev, bev" ~ 2,
str_detect(plugged_in, "bev") | str_detect(run_on_gasoline, "phev") ~ 1,
T ~ 0
),
knowledge_ev = case_when(know_electric_vehicle == "yes" ~ 1, T ~ 0), # need more data cleaning
knowledge_subsidy = case_when(max_subsidy == "7500" ~ 1, T ~ 0)
)
# ----Vehicle Attributes----
data <- data %>%
mutate(
Veh_hh_count = household_veh_count,
Veh_hh_fuel = case_when(
household_veh_fuel == "other" ~ "other",
household_veh_fuel == "icev" ~ "icev_only",
str_detect(household_veh_fuel, "icev") ~ "ev_mix",
T ~ "ev_only"
),
EV_charger = charger_access,
EV_neighbor = neighbor_ev_info,
Veh_primary_fuel = case_when(
is.na(primary_veh_fuel) ~ household_veh_fuel,
T ~ primary_veh_fuel
=======
>>>>>>> 950876ce11dd302ab459e82479e7a12ce6dde129
)
)
# View summary of results
summary(model1)
# Check the 1st order condition: Is the gradient at the solution zero?
model1$gradient
# 2nd order condition: Is the hessian negative definite?
# (If all the eigenvalues are negative, the hessian is negative definite)
eigen(model1$hessian)$values
# Estimate the model
model2 <- logitr(
data = data,
outcome = "choice",
obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
"battery_range_year0",
"battery_degradation",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
)
)
# View summary of results
summary(model2)
source(here::here('code', 'setup.R'))
data <- read_csv(here(
"data",
"main",
"vehicle_choice_data.csv"
))
data <- data %>%
mutate(
price = price / 10000, # 0.5-6
range_bev = range_bev / 100, # 0.5 - 2.5
range_phev = range_phev / 10, # 1 - 4
mileage = mileage * 10, # 2 - 6
age = age * 10, # 2 - 8
operating_cost = operating_cost # 0.3 - 2.5,
) %>%
select(-range, -operating_cost_text, -session_id, -vehicle_type)
# Dummy encode
data <- cbc_encode(
data,
coding = 'dummy',
ref_levels = list(powertrain = 'gas')
) %>%
as.data.frame()
# ---- Estimate MNL model (range:yr0 + degradation) ----
## --- Preference Space ----
mnl_pref <- logitr(
data = data,
outcome = "choice",
obsID = "obsID",
pars = c(
"price",
"mileage",
"age",
"operating_cost",
"range_bev",
"range_phev",
"powertrainbev",
"powertrainphev",
"powertrainhev",
"no_choice"
)
)
# View summary of results
summary(mnl_pref)
# View summary of results
summary(mnl_pref)
# Check the 1st order condition: Is the gradient at the solution zero?
mnl_pref$gradient
# 2nd order condition: Is the hessian negative definite?
# (If all the eigenvalues are negative, the hessian is negative definite)
eigen(mnl_pref$hessian)$values
mnl_wtp <- logitr(
data = data,
outcome = "choice",
obsID = "obsID",
pars = c(
"mileage",
"age",
"operating_cost",
"range_bev",
"range_phev",
"powertrainbev",
"powertrainphev",
"powertrainhev",
"no_choice"
),
scalePar = "price",
numMultiStarts = 10,
numCores = 1
)
# View summary of results
summary(mnl_wtp)
mnl_wtp <- logitr(
data = data,
outcome = "choice",
obsID = "obsID",
pars = c(
"mileage",
"age",
"operating_cost",
"range_bev",
"range_phev",
"powertrainbev",
"powertrainphev",
"powertrainhev",
"no_choice"
),
scalePar = "price",
numMultiStarts = 10,
numCores = 1
)
# View summary of results
summary(mnl_wtp)
# Check the 1st order condition: Is the gradient at the solution zero?
mnl_wtp$gradient
# 2nd order condition: Is the hessian negative definite?
# (If all the eigenvalues are negative, the hessian is negative definite)
eigen(mnl_wtp$hessian)$values
## ---- WTP comparison ----
wtpCompare(mnl_pref, mnl_wtp, scalePar = "price")
# ---- Estimate MXL model ----
## --- WTP Space ----
### --- full ----
mxl_wtp_full <- logitr(
data = data,
outcome = "choice",
obsID = "obsID",
pars = c(
"mileage",
"age",
"operating_cost",
"range_bev",
"range_phev",
"powertrainbev",
"powertrainphev",
"powertrainhev",
"no_choice"
),
scalePar = "price",
randPars = c(
mileage = "n",
age = "n",
operating_cost = "n",
range_bev = "n",
range_phev = "n",
powertrainbev = "n",
powertrainphev = "n",
powertrainhev = "n"
),
numMultiStarts = 10,
numCores = 1
)
# View summary of results
summary(mxl_wtp_full)
### --- No range ----
mxl_wtp_reduced <- logitr(
data = data,
outcome = "choice",
obsID = "obsID",
pars = c(
"mileage",
"age",
"operating_cost",
# "range_bev",
# "range_phev",
"powertrainbev",
"powertrainphev",
"powertrainhev",
"no_choice"
),
scalePar = "price",
randPars = c(
mileage = "n",
age = "n",
operating_cost = "n",
# range_bev = "n",
# range_phev = "n",
powertrainbev = "n",
powertrainphev = "n",
powertrainhev = "n"
),
numMultiStarts = 10,
numCores = 1
)
# View summary of results
summary(mxl_wtp_reduced)
source(here::here('code', 'setup.R'))
data <- read_csv(here(
"data",
"main",
"vehicle_choice_data.csv"
))
data <- data %>%
mutate(
price = price / 10000, # 0.5-6
range_bev = range_bev / 100, # 0.5 - 2.5
range_phev = range_phev / 10, # 1 - 4
mileage = mileage * 10, # 2 - 6
age = age * 10, # 2 - 8
operating_cost = operating_cost # 0.3 - 2.5,
) %>%
select(-range, -operating_cost_text, -session_id, -vehicle_type)
# Dummy encode
data <- cbc_encode(
data,
coding = 'dummy',
ref_levels = list(powertrain = 'gas')
) %>%
as.data.frame()
# ---- Estimate MNL model (range:yr0 + degradation) ----
## --- Preference Space ----
mnl_pref <- logitr(
data = data,
outcome = "choice",
obsID = "obsID",
pars = c(
"price",
"mileage",
"age",
"operating_cost",
"range_bev",
"range_phev",
"powertrainbev",
"powertrainphev",
"powertrainhev",
"no_choice"
)
)
# View summary of results
summary(mnl_pref)
glimpse(data)
unique(data$price)
# Get the model coefficients
coefs <- coef(mnl_pref)
coefs
# Compute WTP estimates
wtp <- coefs / (-1 * coefs['price'])
wtp
# Get the model coefficients and covariance matrix
covariance <- vcov(mnl_pref)
# Take 10,000 draws of the coefficients
coef_draws <- as.data.frame(MASS::mvrnorm(10^4, coefs, covariance))
# Compute WTP for each coefficient draw
wtp_draws = -1 * (coef_draws[, 2:4] / coef_draws[, 1])
head(wtp_draws)
# For each coefficient, get the mean and 95% confidence interval of WTP
wtp_ci <- ci(wtp_draws, level = 0.95)
wtp_ci
# Take 10,000 draws of the coefficients
coef_draws <- as.data.frame(MASS::mvrnorm(10^4, coefs, covariance))
# Compute WTP for each coefficient draw
wtp_draws = -1 * (coef_draws[, 2:10] / coef_draws[, 1])
head(wtp_draws)
# For each coefficient, get the mean and 95% confidence interval of WTP
wtp_ci <- ci(wtp_draws, level = 0.95)
wtp_ci
mnl_wtp <- logitr(
data = data,
outcome = "choice",
obsID = "obsID",
pars = c(
"mileage",
"age",
"operating_cost",
"range_bev",
"range_phev",
"powertrainbev",
"powertrainphev",
"powertrainhev",
"no_choice"
),
scalePar = "price",
numMultiStarts = 10,
numCores = 1
)
# View summary of results
summary(mnl_wtp)
10000 * (-5.4 + 3*0.6)
###############
# Get the model coefficients
coefs <- coef(mnl_pref)
# View summary of results
summary(mnl_pref)
