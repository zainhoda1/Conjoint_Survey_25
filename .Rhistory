obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
#### ranges are highly correlated, so only include one year.
#### Keeping year8 generates higher R2
# "battery_range_year3",
"battery_range_year8",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
)
)
# View summary of results
summary(model1)
# Check the 1st order condition: Is the gradient at the solution zero?
model1$gradient
# 2nd order condition: Is the hessian negative definite?
# (If all the eigenvalues are negative, the hessian is negative definite)
eigen(model1$hessian)$values
# Estimate the model
model2 <- logitr(
data = data,
outcome = "choice",
obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
"battery_range_year0",
"battery_degradation",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
)
)
# View summary of results
summary(model2)
n_distinct(data$session_id)
source(here::here('code', 'setup.R'))
data <- read_csv(here(
"data",
"main",
"battery_choice_data.csv"
))
n_distinct(data$session_id)
glimpse(data)
data <- data %>%
mutate(
veh_mileage = veh_mileage / 10000, #3 - 6
veh_price = veh_price / 10000, # 0.5 - 6
battery_range_year0 = battery_range_year0 / 100, # 1-3
battery_range_year3 = battery_range_year3 / 100, # 1-3
battery_range_year8 = battery_range_year8 / 100, # 0.5 - 2
battery_degradation = (battery_degradation * 10)
) %>%
select(
-starts_with("battery_health"),
-starts_with("time"),
-session_id,
-vehicle_type,
-battery_condition
)
source(here::here('code', 'setup.R'))
pilot_start <- ymd_hms('2025-10-14 21:00:00')
pilot_end <- ymd_hms('2025-10-21 16:00:00')
# Connect to database
#### surveydown::sd_db_config()
db <- sd_db_connect()
# original db
data_raw <- sd_get_data(db)
# removing testing entries
data_raw <- data_raw %>%
filter(!is.na(psid), nchar(psid) >= 10)
# Some special variables:
# session_id = a unique ID for the Run - should be the same across all surveys
# time_start = time stamp when survey was started
# time_end   = time stamp when survey ended
# time_p_*** = Time page *** was reached
# time_q_*** = Time question *** was last answered
# Compute time values for each page
data <- data_raw %>%
mutate(
# Compute time through whole survey
time_start = ymd_hms(time_start, tz = "UTC"),
time_end = ymd_hms(time_end, tz = "UTC"),
time_total = as.numeric(time_end - time_start, units = "secs"),
# Compute time through just the cbc questions
## Vehicle
time_p_vehicle_pageQ1_button = ymd_hms(
time_p_vehicle_pageQ1_button,
tz = "UTC"
),
time_p_vehicle_pageQ6_button = ymd_hms(
time_p_vehicle_pageQ6_button,
tz = "UTC"
),
time_vehicle_cbc_total = as.numeric(
time_p_vehicle_pageQ6_button - time_p_vehicle_pageQ1_button,
units = "secs"
),
## Battery
time_p_battery_pageQ1_button = ymd_hms(
time_p_battery_pageQ1_button,
tz = "UTC"
),
time_p_battery_pageQ6_button = ymd_hms(
time_p_battery_pageQ6_button,
tz = "UTC"
),
time_battery_cbc_total = as.numeric(
time_p_battery_pageQ6_button - time_p_battery_pageQ1_button,
units = "secs"
),
time_min_total = time_total / 60,
time_min_vehicle_cbc = time_vehicle_cbc_total / 60,
time_min_battery_cbc = time_battery_cbc_total / 60
)
data <- data %>%
# Bot
filter(is.na(attention_check_toyota)) %>%
# Survey question removed
select(
!c(
attention_check_toyota,
attitudes_1_a,
attitudes_1_b,
attitudes_2_a,
attitudes_2_b,
battery_attribute
)
) %>%
# Drop people who got screened out
filter(!is.na(current_page), current_page == "end") %>%
select(-current_page) %>%
# Drop those who completed before the adjustments
filter(time_start > pilot_end) %>%
#filter(time_start <= pilot_end) %>%
# Drop respondents that had a missing budget (somehow)
filter(!is.na(next_veh_budget))
#n_distinct(data$session_id)  # 98
write_csv(
data,
here(
"data",
"main",
"survey_data.csv"
)
)
source(here::here('code', 'setup.R'))
# Import raw data
data_raw <- read_csv(here(
"data",
"main",
"survey_data.csv"
))
# Read in choice questions and join it to the choice_data
survey <- read_parquet(here(
"data",
"doe",
"design-10-14-25",
'design_vehicle.parquet'
))
# Compute time values for each page
data <- data_raw %>%
# Select important columns
select(
session_id,
time_start,
time_min_total,
time_min_vehicle_cbc,
respID,
next_veh_budget,
next_veh_style,
starts_with("vehicle_cbc_q")
)
# Drop anyone who didn't complete all choice questions
data <- data %>%
filter(!is.na(vehicle_cbc_q1_button)) %>%
filter(!is.na(vehicle_cbc_q2_button)) %>%
filter(!is.na(vehicle_cbc_q3_button)) %>%
filter(!is.na(vehicle_cbc_q4_button)) %>%
filter(!is.na(vehicle_cbc_q5_button)) %>%
filter(!is.na(vehicle_cbc_q6_button))
nrow(data)
# Drop anyone who got the demo question wrong:
data <- data %>%
filter(vehicle_cbc_q0_button %in% c('option_1', 'option_4')) %>%
select(-vehicle_cbc_q0_button)
nrow(data)
# Drop anyone who answered the same question for all choice questions
data <- data %>%
mutate(
cbc_all_same = (vehicle_cbc_q1_button == vehicle_cbc_q2_button) &
(vehicle_cbc_q2_button == vehicle_cbc_q3_button) &
(vehicle_cbc_q3_button == vehicle_cbc_q4_button) &
(vehicle_cbc_q4_button == vehicle_cbc_q5_button) &
(vehicle_cbc_q5_button == vehicle_cbc_q6_button)
) %>%
filter(!cbc_all_same) %>%
select(-cbc_all_same)
nrow(data)
# Drop respondents who went too fast
# Look at summary of completion times
summary(data$time_min_total)
summary(data$time_min_vehicle_cbc)
# Drop anyone who finished the choice question section in under 1 minute
data <- data %>%
filter(time_min_vehicle_cbc >= 0.5) %>%
# dropping non-unique respID (keeping first one)
distinct(respID, .keep_all = TRUE)
nrow(data)
# Create choice data ---------
# First convert the data to long format
choice_data <- data %>%
pivot_longer(
cols = vehicle_cbc_q1_button:vehicle_cbc_q6_button,
names_to = "qID",
values_to = "choice"
) %>%
# Convert the qID variable and choice column to a number
mutate(
qID = parse_number(qID),
choice = parse_number(choice),
vehicle_type = case_when(
next_veh_style == 'Car / sedan / hatchback' ~ 'car',
next_veh_style == 'SUV / crossover' ~ 'suv'
)
) %>%
select(-next_veh_style)
head(choice_data)
choice_data <- choice_data %>%
left_join(survey, by = c("vehicle_type", "respID", "qID"))
# Convert choice column to 1 or 0 based on if the alternative was chosen
choice_data <- choice_data %>%
mutate(
choice = ifelse(choice == altID, 1, 0),
price = price * next_veh_budget
)
head(choice_data)
# Remove bad respID
choice_data <- choice_data %>%
filter(respID != 3587)
data <- data %>%
filter(respID != 3587)
# Create new values for respID & obsID
nRespondents <- nrow(data)
nAlts <- max(survey$altID)
nQuestions <- max(survey$qID)
choice_data$respID <- rep(seq(nRespondents), each = nAlts * nQuestions)
choice_data$obsID <- rep(seq(nRespondents * nQuestions), each = nAlts)
# Reorder columns - it's nice to have the "ID" variables first
choice_data <- choice_data %>%
select(ends_with("ID"), "choice", everything())
head(choice_data)
# Save cleaned data for modeling
write_csv(
choice_data,
here(
"data",
"main",
"vehicle_choice_data.csv"
)
)
source(here::here('code', 'setup.R'))
# Import raw data
data_raw <- read_csv(here(
"data",
"main",
"survey_data.csv"
))
# Read in choice questions and join it to the choice_data
survey <- read_parquet(here(
"data",
"doe",
"design-10-14-25",
'design_battery.parquet'
))
# Format and join the three surveys -------
# Compute time values for each page
data <- data_raw %>%
# Select important columns
select(
session_id,
time_start,
time_min_total,
time_min_battery_cbc,
battery_respID,
next_veh_budget,
next_veh_style,
starts_with("battery_cbc_q"),
-battery_cbc_q0_button
) %>%
rename(respID = battery_respID)  #changed battery_respID to just respID for ease of use
glimpse(data)
# Drop respondents who went too fast
# Look at summary of completion times
summary(data$time_min_total)
summary(data$time_min_battery_cbc)
data <- data %>%
# Drop anyone who finished the choice question section in under 30 second
filter(time_min_battery_cbc >= 0.5) %>%
# dropping non-unique respID (keeping first one)
distinct(respID, .keep_all = TRUE)
# Drop anyone who didn't complete all choice questions
data <- data %>%
filter(!is.na(battery_cbc_q1_button)) %>%
filter(!is.na(battery_cbc_q2_button)) %>%
filter(!is.na(battery_cbc_q3_button)) %>%
filter(!is.na(battery_cbc_q4_button)) %>%
filter(!is.na(battery_cbc_q5_button)) %>%
filter(!is.na(battery_cbc_q6_button))
nrow(data)
# Drop anyone who answered the same question for all choice questions
data <- data %>%
mutate(
cbc_all_same = (battery_cbc_q1_button == battery_cbc_q2_button) &
(battery_cbc_q2_button == battery_cbc_q3_button) &
(battery_cbc_q3_button == battery_cbc_q4_button) &
(battery_cbc_q4_button == battery_cbc_q5_button) &
(battery_cbc_q5_button == battery_cbc_q6_button)
) %>%
filter(!cbc_all_same) %>%
select(-cbc_all_same)
nrow(data)
# Create choice data ---------
# First convert the data to long format
choice_data <- data %>%
pivot_longer(
cols = battery_cbc_q1_button:battery_cbc_q6_button,
names_to = "qID",
values_to = "choice"
) %>%
# Convert the qID variable and choice column to a number
mutate(
qID = parse_number(qID),
choice = parse_number(choice),
vehicle_type = case_when(
next_veh_style == 'Car / sedan / hatchback' ~ 'car',
next_veh_style == 'SUV / crossover' ~ 'suv'
)
) %>%
select(-next_veh_style)
head(choice_data)
glimpse(choice_data)
glimpse(survey)
choice_data <- choice_data %>%
left_join(survey, by = c("respID", "qID"))
# Convert choice column to 1 or 0 based on if the alternative was chosen
choice_data <- choice_data %>%
mutate(
choice = ifelse(choice == altID, 1, 0),
veh_price = veh_price * next_veh_budget
)
glimpse(choice_data)
nrow(data)
# Create new values for respID & obsID
nRespondents <- nrow(data)
nAlts <- max(survey$altID)
nQuestions <- max(survey$qID)
choice_data$respID <- rep(seq(nRespondents), each = nAlts * nQuestions)
choice_data$obsID <- rep(seq(nRespondents * nQuestions), each = nAlts)
# Reorder columns - it's nice to have the "ID" variables first
choice_data <- choice_data %>%
select(ends_with("ID"), "choice", everything())
head(choice_data)
# Save cleaned data for modeling
write_csv(
choice_data,
here(
"data",
"main",
"battery_choice_data.csv"
)
)
source(here::here('code', 'setup.R'))
# --------------------------------------------------------------------------
# Load the data set:
data <- read_csv(here(
"data",
"main",
"vehicle_choice_data.csv"
))
head(data)
#n_distinct(data$session_id)  #334
glimpse(data)
data <- data %>%
mutate(
price = price / 10000, # 0.5-6
range_bev = range_bev / 100, # 0.5 - 2.5
range_phev = range_phev / 10, # 1 - 4
mileage = mileage * 10, # 2 - 6
age = age * 10, # 2 - 8
operating_cost = operating_cost / 10 # 0.3 - 2.5,
) %>%
select(-range, -operating_cost_text, -session_id, -vehicle_type)
# Dummy encode
data <- cbc_encode(data, coding = 'dummy', ref_levels = list(powertrain='gas')) %>%
as.data.frame()
glimpse(data)
# Estimate MNL model
# First create some dummy coded variables for categorical variables
#data <- dummy_cols(data, c('powertrain'))
data %>%
count(choice, qID)
data %>%
count(no_choice, choice)
# Estimate the model
model <- logitr(
data = data,
outcome = "choice",
obsID = "obsID",
pars = c(
"price",
"mileage",
"age",
"operating_cost",
"range_bev",
"range_phev",
"powertrainbev",
"powertrainphev",
"powertrainhev",
"no_choice"
)
)
# View summary of results
summary(model)
# Check the 1st order condition: Is the gradient at the solution zero?
model$gradient
# 2nd order condition: Is the hessian negative definite?
# (If all the eigenvalues are negative, the hessian is negative definite)
eigen(model$hessian)$values
source(here::here('code', 'setup.R'))
# -----------------------------------------------------------------------------
# Load the data set:
data <- read_csv(here(
"data",
"main",
"battery_choice_data.csv"
))
#head(data)
#n_distinct(data$session_id)  #373
glimpse(data)
data <- data %>%
mutate(
veh_mileage = veh_mileage / 10000, #3 - 6
veh_price = veh_price / 10000, # 0.5 - 6
battery_range_year0 = battery_range_year0 / 100, # 1-3
battery_range_year3 = battery_range_year3 / 100, # 1-3
battery_range_year8 = battery_range_year8 / 100, # 0.5 - 2
battery_degradation = (battery_degradation * 10)
) %>%
select(
-starts_with("battery_health"),
-starts_with("time"),
-session_id,
-vehicle_type,
-battery_condition
)
# Dummy encode
data <- cbc_encode(
data,
coding = 'dummy',
ref_levels = list(battery_refurbish = 'original')
) %>%
as.data.frame() %>%
clean_names()
# Estimate MNL model
# First create some dummy coded variables for categorical variables
#data <- dummy_cols(data, c('battery_refurbish', 'degradation_high'))
# Clean up names of created variables
glimpse(data)
# Estimate the model
model1 <- logitr(
data = data,
outcome = "choice",
obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
#### ranges are highly correlated, so only include one year.
#### Keeping year8 generates higher R2
# "battery_range_year3",
"battery_range_year8",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
)
)
# View summary of results
summary(model1)
# Check the 1st order condition: Is the gradient at the solution zero?
model1$gradient
# 2nd order condition: Is the hessian negative definite?
# (If all the eigenvalues are negative, the hessian is negative definite)
eigen(model1$hessian)$values
# Estimate the model
model2 <- logitr(
data = data,
outcome = "choice",
obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
"battery_range_year0",
"battery_degradation",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
)
)
# View summary of results
summary(model2)
