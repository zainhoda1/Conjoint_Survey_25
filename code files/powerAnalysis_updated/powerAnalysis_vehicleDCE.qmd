---
title: "Power Analysis - Vehicle Choices"
format: html
theme: united
execute:
  cache: true
---

```{r}
#| label: setup
#| include: false

knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE,
    fig.path = "figs/",
    fig.width = 7.252,
    fig.height = 4,
    comment = "#>",
    fig.retina = 3
)

library(tidyverse)
library(cbcTools)
library(logitr)
library(here)
```



# ----------------------------
# For car
## Step 1: Generate Profiles
```{r}
profiles <- cbc_profiles(
  powertrain = c('Gasoline', 'Battery Electric', 'Plug-in Hybrid', 'Gas Hybrid'),
  price = seq(0.8, 1.1, 0.1),
  range = c(0, seq(0.5, 2.5, 0.25)), # unit: 100
  mileage = seq(2, 6, 0.5), # unit: 10000
  make_year = seq(2, 10),  # vehicle age: 2 -10
  operating_cost = seq(3, 21, 3)
)

```

### Resrictions
Only include profiles with feasible operation costs
```{r}
profiles_restricted <- cbc_restrict(
  profiles,
  # BEV range restrictions
  (powertrain == "Battery Electric") & (range < 0.5),
  # Gas efficiency restrictions
  (powertrain == "Gasoline") & (operating_cost < 9),
  (powertrain != "Gasoline") & (operating_cost >= 18)
)

# table(profiles_restricted$operating_cost)
```

## Step 2: Set up priors

| Attribute | Expectation | Theory  | Suggested Sign |
|--------------|---------------|-----------|-----------|
| powertrain       | ICEV > HEV > PHEV > BEV | Concerns about battery health | Negative (−) | 
| price        | Lower price preferred   | Standard economic theory (price disutility)  |Negative (−)|
| range      | More range preferred          | Reduces range anxiety    | Positive (+)|
| mileage          | Lower mileage preferred           |Higher mileage = older/worn vehicle    |Negative (−)|
| make_year     | Newer car preferred   | Risk aversion, resale concerns    |Negative (−)|
| operating_cost | Lower cost preferred   |  Standard economic theory (price disutility) | Negative (−)|


### Fixed Parameters
```{r}
priors_fixed_parameter <- cbc_priors(
  profiles = profiles_restricted,
  # powertrain: categorical (effects coded or dummy)
  powertrain = c("Battery Electric" = -1.0, "Plug-in Hybrid" = 1.0,  "Gas Hybrid" = 0.5),
  # price: scaled by 1,000s
  price = -0.2,
  # range bev: scaled by 100s → positive effect
  range = 0.5,
  # range phev: scaled by 100s → positive effect
  mileage = -0.5,
  # make_year: higher means older → negative effect
  make_year = -0.2,
  # operating cost: higher means worse → negative effect
  operating_cost = -0.3,
  no_choice = 0.5

  
)



# priors_fixed_parameter
```

### Random Parameters
```{r}


# priors_random_parameter
```




## Step 3: Generate Designs


- **shortcut**: The "shortcut" method balances attribute level frequencies while avoiding duplicate profiles within questions

```{r}
design_rand <- cbc_design(
  profiles = profiles_restricted,
  method = 'random',
  n_resp = 4000, # Number of respondents
  n_alts = 3, # Number of alternatives per question
  n_q = 6, # Number of questions per respondent
  no_choice = TRUE,
  priors = priors_fixed_parameter
  
)
```


## Check for balance:


```{r}
cbc_inspect(design_rand)

```


## Check that counts by powertrain are even

```{r}
design_rand %>%
  tibble() %>%
  select(starts_with('power'), no_choice) %>%
  janitor::clean_names() %>%
  count(
    powertrain_battery_electric,
    powertrain_plug_in_hybrid,
    powertrain_gas_hybrid,
    no_choice
  )

```

## Remove duplicates:

```{r}
design_rand$range[design_rand$"powertrainBattery Electric"  !='1'] <- 0


duplicates <- design_rand[duplicated(design_rand[c('respID',
                                         'qID',
                                         'powertrainGas Hybrid',
                                         'powertrainPlug-in Hybrid',
                                         'powertrainBattery Electric',
                                         'price',
                                         'range',
                                         'mileage',
                                         'make_year',
                                         'operating_cost' )]), ]

design_rand <- design_rand[!duplicated(design_rand[c('respID',
                                         'qID',
                                         'powertrainGas Hybrid',
                                         'powertrainPlug-in Hybrid',
                                         'powertrainBattery Electric',
                                         'price',
                                         'range',
                                         'mileage',
                                         'make_year',
                                         'operating_cost' )]), ]




```


## Check that counts by powertrain are even

```{r}
design_rand %>%
  tibble() %>%
  select(starts_with('power'), no_choice) %>%
  janitor::clean_names() %>%
  count(
    powertrain_battery_electric,
    powertrain_plug_in_hybrid,
    powertrain_gas_hybrid,
    no_choice
  )

```




```{r}

choices <- cbc_choices(design_rand)

```




```{r}
#power <- cbc_power(choices)


# plot(power, type = "power", power_threshold = 0.9)
# summary(power, power_threshold = 0.9)


```