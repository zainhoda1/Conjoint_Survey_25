# range phev: scaled by 100s → positive effect
mileage = -0.5,
# make_year: higher means older → negative effect
make_year = -0.2,
# operating cost: higher means worse → negative effect
operating_cost = -0.3,
no_choice = 0.5
)
# priors_fixed_parameter
# Chunk 5
priors_random_parameter <- cbc_priors(
profiles = profiles,
# powertrain: categorical (effects coded or dummy)
powertrain = rand_spec("n", c(-0.1, -0.2, -0.3), c( 0.1, 0.1, 0.1)),
price = -0.1, # Assume $1,000 price increase = -0.1 utility
# range bev: scaled by 100s → positive effect
range = 0.5,
# mileage: scaled by 10,000s → negative effect
mileage = -0.5,
# make_year: higher means older → negative effect
make_year = -0.2,
# operating cost: higher means worse → negative effect
operating_cost = -0.3,
no_choice = 0.5
)
# priors_random_parameter
design_rand <- cbc_design(
profiles = profiles_restricted,
method = 'random',
n_resp = 4000, # Number of respondents
n_alts = 3, # Number of alternatives per question
n_q = 6, # Number of questions per respondent
no_choice = TRUE,
priors = priors_fixed_parameter
)
cbc_inspect(design_rand)
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(
powertrain_electric,
powertrain_plug_in_hybrid,
powertrain_hybrid,
no_choice
)
View(design_rand)
# Chunk 1: setup
#| label: setup
#| include: false
knitr::opts_chunk$set(
warning = FALSE,
message = FALSE,
fig.path = "figs/",
fig.width = 7.252,
fig.height = 4,
comment = "#>",
fig.retina = 3
)
library(tidyverse)
library(cbcTools)
library(logitr)
library(here)
# Chunk 2
profiles <- cbc_profiles(
powertrain = c('Gasoline', 'Electric', 'Plug-in Hybrid', 'Hybrid'),
price = seq(0.8, 1.1, 0.1),
range = c(0, seq(0.5, 2.5, 0.25)), # unit: 100
mileage = seq(2, 6, 0.5), # unit: 10000
make_year = seq(2, 10),  # vehicle age: 2 -10
operating_cost = seq(3, 21, 3)
)
# Chunk 3
profiles_restricted <- cbc_restrict(
profiles,
# BEV range restrictions
# (powertrain == "Gasoline") & (range != 0),
# (powertrain == "Hybrid") & (range != 0),
# (powertrain == "Plug-in Hybrid") & (range != 0),
# (powertrain == "Electric") & (range < 0.5),
# Gas efficiency restrictions
(powertrain == "Gasoline") & (operating_cost < 9),
(powertrain != "Gasoline") & (operating_cost >= 18)
)
# table(profiles_restricted$operating_cost)
# Chunk 4
priors_fixed_parameter <- cbc_priors(
profiles = profiles_restricted,
# powertrain: categorical (effects coded or dummy)
powertrain = c("Electric" = -1.0, "Plug-in Hybrid" = 1.0,  "Hybrid" = 0.5),
# price: scaled by 1,000s
price = -0.2,
# range bev: scaled by 100s → positive effect
range = 0.5,
# range phev: scaled by 100s → positive effect
mileage = -0.5,
# make_year: higher means older → negative effect
make_year = -0.2,
# operating cost: higher means worse → negative effect
operating_cost = -0.3,
no_choice = 0.5
)
# priors_fixed_parameter
# Chunk 5
priors_random_parameter <- cbc_priors(
profiles = profiles,
# powertrain: categorical (effects coded or dummy)
powertrain = rand_spec("n", c(-0.1, -0.2, -0.3), c( 0.1, 0.1, 0.1)),
price = -0.1, # Assume $1,000 price increase = -0.1 utility
# range bev: scaled by 100s → positive effect
range = 0.5,
# mileage: scaled by 10,000s → negative effect
mileage = -0.5,
# make_year: higher means older → negative effect
make_year = -0.2,
# operating cost: higher means worse → negative effect
operating_cost = -0.3,
no_choice = 0.5
)
# priors_random_parameter
# Chunk 6
design_rand <- cbc_design(
profiles = profiles_restricted,
method = 'random',
n_resp = 4000, # Number of respondents
n_alts = 3, # Number of alternatives per question
n_q = 6, # Number of questions per respondent
no_choice = TRUE,
priors = priors_fixed_parameter
)
# Chunk 7
cbc_inspect(design_rand)
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(
powertrain_electric,
powertrain_plug_in_hybrid,
powertrain_hybrid,
no_choice
)
View(design_rand)
colnames(design_rand)
design_rand$range[design$powertrainElectric  !='1'] <- 0
design_rand$range[design_rand$powertrainElectric  !='1'] <- 0
View(design_rand)
# Chunk 1: setup
#| label: setup
#| include: false
knitr::opts_chunk$set(
warning = FALSE,
message = FALSE,
fig.path = "figs/",
fig.width = 7.252,
fig.height = 4,
comment = "#>",
fig.retina = 3
)
library(tidyverse)
library(cbcTools)
library(logitr)
library(here)
# Chunk 2
profiles <- cbc_profiles(
powertrain = c('Gasoline', 'Battery Electric', 'Plug-in Hybrid', 'Gas Hybrid'),
price = seq(0.8, 1.1, 0.1),
range = c(0, seq(0.5, 2.5, 0.25)), # unit: 100
mileage = seq(2, 6, 0.5), # unit: 10000
make_year = seq(2, 10),  # vehicle age: 2 -10
operating_cost = seq(3, 21, 3)
)
# Chunk 3
profiles_restricted <- cbc_restrict(
profiles,
# BEV range restrictions
# (powertrain == "Gasoline") & (range != 0),
# (powertrain == "Hybrid") & (range != 0),
# (powertrain == "Plug-in Hybrid") & (range != 0),
# (powertrain == "Electric") & (range < 0.5),
# Gas efficiency restrictions
(powertrain == "Gasoline") & (operating_cost < 9),
(powertrain != "Gasoline") & (operating_cost >= 18)
)
# table(profiles_restricted$operating_cost)
# Chunk 4
priors_fixed_parameter <- cbc_priors(
profiles = profiles_restricted,
# powertrain: categorical (effects coded or dummy)
powertrain = c("Electric" = -1.0, "Plug-in Hybrid" = 1.0,  "Hybrid" = 0.5),
# price: scaled by 1,000s
price = -0.2,
# range bev: scaled by 100s → positive effect
range = 0.5,
# range phev: scaled by 100s → positive effect
mileage = -0.5,
# make_year: higher means older → negative effect
make_year = -0.2,
# operating cost: higher means worse → negative effect
operating_cost = -0.3,
no_choice = 0.5
)
# Chunk 1: setup
#| label: setup
#| include: false
knitr::opts_chunk$set(
warning = FALSE,
message = FALSE,
fig.path = "figs/",
fig.width = 7.252,
fig.height = 4,
comment = "#>",
fig.retina = 3
)
library(tidyverse)
library(cbcTools)
library(logitr)
library(here)
profiles <- cbc_profiles(
powertrain = c('Gasoline', 'Battery Electric', 'Plug-in Hybrid', 'Gas Hybrid'),
price = seq(0.8, 1.1, 0.1),
range = c(0, seq(0.5, 2.5, 0.25)), # unit: 100
mileage = seq(2, 6, 0.5), # unit: 10000
make_year = seq(2, 10),  # vehicle age: 2 -10
operating_cost = seq(3, 21, 3)
)
profiles_restricted <- cbc_restrict(
profiles,
# BEV range restrictions
# (powertrain == "Gasoline") & (range != 0),
# (powertrain == "Hybrid") & (range != 0),
# (powertrain == "Plug-in Hybrid") & (range != 0),
# (powertrain == "Electric") & (range < 0.5),
# Gas efficiency restrictions
(powertrain == "Gasoline") & (operating_cost < 9),
(powertrain != "Gasoline") & (operating_cost >= 18)
)
# table(profiles_restricted$operating_cost)
priors_fixed_parameter <- cbc_priors(
profiles = profiles_restricted,
# powertrain: categorical (effects coded or dummy)
powertrain = c("Electric" = -1.0, "Plug-in Hybrid" = 1.0,  "Hybrid" = 0.5),
# price: scaled by 1,000s
price = -0.2,
# range bev: scaled by 100s → positive effect
range = 0.5,
# range phev: scaled by 100s → positive effect
mileage = -0.5,
# make_year: higher means older → negative effect
make_year = -0.2,
# operating cost: higher means worse → negative effect
operating_cost = -0.3,
no_choice = 0.5
)
# Chunk 1: setup
#| label: setup
#| include: false
knitr::opts_chunk$set(
warning = FALSE,
message = FALSE,
fig.path = "figs/",
fig.width = 7.252,
fig.height = 4,
comment = "#>",
fig.retina = 3
)
library(tidyverse)
library(cbcTools)
library(logitr)
library(here)
# Chunk 2
profiles <- cbc_profiles(
powertrain = c('Gasoline', 'Battery Electric', 'Plug-in Hybrid', 'Gas Hybrid'),
price = seq(0.8, 1.1, 0.1),
range = c(0, seq(0.5, 2.5, 0.25)), # unit: 100
mileage = seq(2, 6, 0.5), # unit: 10000
make_year = seq(2, 10),  # vehicle age: 2 -10
operating_cost = seq(3, 21, 3)
)
# Chunk 3
profiles_restricted <- cbc_restrict(
profiles,
# BEV range restrictions
# (powertrain == "Gasoline") & (range != 0),
# (powertrain == "Hybrid") & (range != 0),
# (powertrain == "Plug-in Hybrid") & (range != 0),
# (powertrain == "Electric") & (range < 0.5),
# Gas efficiency restrictions
(powertrain == "Gasoline") & (operating_cost < 9),
(powertrain != "Gasoline") & (operating_cost >= 18)
)
# table(profiles_restricted$operating_cost)
# Chunk 4
priors_fixed_parameter <- cbc_priors(
profiles = profiles_restricted,
# powertrain: categorical (effects coded or dummy)
powertrain = c("Battery Electric" = -1.0, "Plug-in Hybrid" = 1.0,  "Gas Hybrid" = 0.5),
# price: scaled by 1,000s
price = -0.2,
# range bev: scaled by 100s → positive effect
range = 0.5,
# range phev: scaled by 100s → positive effect
mileage = -0.5,
# make_year: higher means older → negative effect
make_year = -0.2,
# operating cost: higher means worse → negative effect
operating_cost = -0.3,
no_choice = 0.5
)
# priors_fixed_parameter
# Chunk 5
# priors_random_parameter
# Chunk 6
design_rand <- cbc_design(
profiles = profiles_restricted,
method = 'random',
n_resp = 4000, # Number of respondents
n_alts = 3, # Number of alternatives per question
n_q = 6, # Number of questions per respondent
no_choice = TRUE,
priors = priors_fixed_parameter
)
# Chunk 7
cbc_inspect(design_rand)
# Chunk 8
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(
powertrain_electric,
powertrain_plug_in_hybrid,
powertrain_hybrid,
no_choice
)
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names()
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(
powertrain_battery_electric,
powertrain_plug_in_hybrid,
powertrain_gas_hybrid,
no_choice
)
View(design_rand)
# Chunk 1: setup
#| label: setup
#| include: false
knitr::opts_chunk$set(
warning = FALSE,
message = FALSE,
fig.path = "figs/",
fig.width = 7.252,
fig.height = 4,
comment = "#>",
fig.retina = 3
)
library(tidyverse)
library(cbcTools)
library(logitr)
library(here)
# Chunk 2
profiles <- cbc_profiles(
powertrain = c('Gasoline', 'Battery Electric', 'Plug-in Hybrid', 'Gas Hybrid'),
price = seq(0.8, 1.1, 0.1),
range = c(0, seq(0.5, 2.5, 0.25)), # unit: 100
mileage = seq(2, 6, 0.5), # unit: 10000
make_year = seq(2, 10),  # vehicle age: 2 -10
operating_cost = seq(3, 21, 3)
)
# Chunk 3
profiles_restricted <- cbc_restrict(
profiles,
# BEV range restrictions
# (powertrain == "Gasoline") & (range != 0),
# (powertrain == "Hybrid") & (range != 0),
# (powertrain == "Plug-in Hybrid") & (range != 0),
(powertrain == "Battery Electric") & (range < 0.5),
# Gas efficiency restrictions
(powertrain == "Gasoline") & (operating_cost < 9),
(powertrain != "Gasoline") & (operating_cost >= 18)
)
# table(profiles_restricted$operating_cost)
# Chunk 4
priors_fixed_parameter <- cbc_priors(
profiles = profiles_restricted,
# powertrain: categorical (effects coded or dummy)
powertrain = c("Battery Electric" = -1.0, "Plug-in Hybrid" = 1.0,  "Gas Hybrid" = 0.5),
# price: scaled by 1,000s
price = -0.2,
# range bev: scaled by 100s → positive effect
range = 0.5,
# range phev: scaled by 100s → positive effect
mileage = -0.5,
# make_year: higher means older → negative effect
make_year = -0.2,
# operating cost: higher means worse → negative effect
operating_cost = -0.3,
no_choice = 0.5
)
# priors_fixed_parameter
# Chunk 5
# priors_random_parameter
# Chunk 6
design_rand <- cbc_design(
profiles = profiles_restricted,
method = 'random',
n_resp = 4000, # Number of respondents
n_alts = 3, # Number of alternatives per question
n_q = 6, # Number of questions per respondent
no_choice = TRUE,
priors = priors_fixed_parameter
)
# Chunk 7
cbc_inspect(design_rand)
# Chunk 8
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(
powertrain_battery_electric,
powertrain_plug_in_hybrid,
powertrain_gas_hybrid,
no_choice
)
colnames(design_rand)
design_rand$range[design_rand$"powertrainBattery Electric"  !='1'] <- 0
View(design_rand)
duplicates <- design[duplicated(design[c('respID',
'qID',
'powertrain gas hybrid',
'powertrainPlug-in hybrid',
'powertrainBattery electric',
'price',
'range',
'mileage',
'make_year',
'operating_cost' )]), ]
duplicates <- design_rand[duplicated(design_rand[c('respID',
'qID',
'powertrain gas hybrid',
'powertrainPlug-in hybrid',
'powertrainBattery electric',
'price',
'range',
'mileage',
'make_year',
'operating_cost' )]), ]
duplicates <- design_rand[duplicated(design_rand[c('respID',
'qID',
'powertrainGas Hybrid',
'powertrainPlug-in Hybrid',
'powertrainBattery Electric',
'price',
'range',
'mileage',
'make_year',
'operating_cost' )]), ]
View(duplicates)
design <- design[!duplicated(design[c('respID',
'qID',
'powertrainGas Hybrid',
'powertrainPlug-in Hybrid',
'powertrainBattery Electric',
'price',
'range',
'mileage',
'make_year',
'operating_cost' )]), ]
design_rand <- design_rand[!duplicated(design_rand[c('respID',
'qID',
'powertrainGas Hybrid',
'powertrainPlug-in Hybrid',
'powertrainBattery Electric',
'price',
'range',
'mileage',
'make_year',
'operating_cost' )]), ]
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(
powertrain_battery_electric,
powertrain_plug_in_hybrid,
powertrain_gas_hybrid,
no_choice
)
cbc_inspect(design_rand)
choices <- cbc_choices(design_rand)
power <- cbc_power(choices)
power_basic <- cbc_power(
data = choices,
outcome = "choice",
pars = c(
# Specific dummy variables
"range_bev",
"powertrainElectric",
"powertrainPlug-in Hybrid",
"powertrainHybrid"
),
obsID = "obsID",
n_q = 6,
n_breaks = 10
)
