choices_random_fixed_parameter <- cbc_choices(design_random_fixed_parameter, priors = priors_fixed)
choices_random_random_parameter <- cbc_choices(design_random_random_parameter, priors = priors_random_parameter)
# choices_shortcut <- cbc_choices(design_shortcut)
# choices_shortcut_fixed_parameter <- cbc_choices(design_shortcut_fixed_parameter,priors = priors_fixed)
# Chunk 15
choices_cat <- cbc_decode(choices_random_fixed_parameter %>%
select (-no_choice))
# Filter for the chosen rows only
choices_cat <- choices_cat[which(choices_cat$choice == 1), ]
# Counts of choices made for each attribute level
table(choices_cat$veh_mileage)
table(choices_cat$veh_price)
table(choices_cat$battery_refurbish)
table(choices_cat$battery_range_year0)
table(choices_cat$battery_degradation)
# Chunk 16
choices_cat <- cbc_decode(choices_random_random_parameter  %>%
select (-no_choice))
# Filter for the chosen rows only
choices_cat <- choices_cat[which(choices_cat$choice == 1), ]
# Counts of choices made for each attribute level
table(choices_cat$veh_mileage)
table(choices_cat$veh_price)
table(choices_cat$battery_refurbish)
table(choices_cat$battery_range_year0)
table(choices_cat$battery_degradation)
# Chunk 17
# choices_cat <- cbc_decode(choices_shortcut)
#
# # Filter for the chosen rows only
# choices_cat <- choices_cat[which(choices_cat$choice == 1), ]
#
# # Counts of choices made for each attribute level
# table(choices_cat$veh_mileage)
# table(choices_cat$veh_price)
# table(choices_cat$battery_refurbish)
# table(choices_cat$battery_range_year0)
# table(choices_cat$battery_degradation)
# Chunk 18
# choices_cat_fixed_parameter <- cbc_decode(choices_shortcut_fixed_parameter)
#
# # Filter for the chosen rows only
# choices_cat <- choices_cat[which(choices_cat$choice == 1), ]
#
# # Counts of choices made for each attribute level
# table(choices_cat$veh_mileage)
# table(choices_cat$veh_price)
# table(choices_cat$battery_refurbish)
# table(choices_cat$battery_range_year0)
# table(choices_cat$battery_degradation)
# Chunk 19
power_random_fixed_parameter <- cbc_power(
data=choices_random_fixed_parameter,
outcome = "choice",
obsID = "obsID",
n_q = 6,
n_breaks = 10
)
plot(power_random_fixed_parameter, type = "power", power_threshold = 0.9)
plot(power_random_fixed_parameter, type = "se")
summary(power_random_fixed_parameter, power_threshold = 0.9)
# Chunk 20
power_random_random_parameter <- cbc_power(
data=choices_random_random_parameter,
outcome = "choice",
obsID = "obsID",
n_q = 6,
n_breaks = 10)
plot(power_random_random_parameter, type = "power", power_threshold = 0.9)
plot(power_random_random_parameter, type = "se")
summary(power_random_random_parameter, power_threshold = 0.9)
# Chunk 21
# power_shortcut <- cbc_power(
#   data=choices_shortcut,
#   outcome = "choice",
#   obsID = "obsID",
#   n_q = 6,
#   n_breaks = 10)
#
# plot(power_shortcut, type = "power", power_threshold = 0.9)
# plot(power_shortcut, type = "se", power_threshold = 0.9)
# summary(power_shortcut, power_threshold = 0.9)
# Chunk 22
# power_shortcut_fixed_parameter <- cbc_power(
#   data=choices_shortcut_fixed_parameter,
#   outcome = "choice",
#   obsID = "obsID",
#   n_q = 6,
#   n_breaks = 10)
#
# plot(power_shortcut_fixed_parameter, type = "power", power_threshold = 0.9)
# plot(power_shortcut_fixed_parameter, type = "se", power_threshold = 0.9)
# summary(power_shortcut_fixed_parameter, power_threshold = 0.9)
# Chunk 23
plot_compare_power(
random_fixed_parameter = power_random_fixed_parameter,
random_random_parameter = power_random_random_parameter,
# shortcut = power_shortcut,
# shortcut_fixed_parameter = power_shortcut_fixed_parameter,
type = "power"
)
plot_compare_power(
random_fixed_parameter = power_random_fixed_parameter,
random_random_parameter = power_random_random_parameter,
# shortcut = power_shortcut,
# shortcut_fixed_parameter = power_shortcut_fixed_parameter,
type = "se"
)
design_random_fixed_parameter_origin<-design_random_fixed_parameter
View(design_random_fixed_parameter_origin)
design_random_fixed_parameter<-cbc_decode(design_random_fixed_parameter %>% select(-no_choice))
View(design_random_fixed_parameter)
design_random_fixed_parameter<-cbc_decode(design_random_fixed_parameter)
View(design_random_fixed_parameter_origin)
design_random_fixed_parameter <- design_random_fixed_parameter_origin %>% select(-no_choice)
design_random_fixed_parameter<-cbc_decode(design_random_fixed_parameter)
design_random_fixed_parameter <- cbc_design(
profiles = profiles,
priors = priors_fixed,
method = "random", # randomized full-factorial design
n_resp   = 3000, # Number of respondents
n_alts   = 3,    # Number of alternatives per question
n_q      = 6,    # Number of questions per respondent #6
#remove_dominant = TRUE,
no_choice = TRUE
)
design_random_fixed_parameter_origin<-design_random_fixed_parameter
View(design_random_fixed_parameter_origin)
#design_random_fixed_parameter <- design_random_fixed_parameter %>% select(-no_choice)
design_random_fixed_parameter<-cbc_decode(design_random_fixed_parameter)
?cbc_decode
surveydown::sd_db_config()
shiny::runApp('survey_updated_pretest')
battery_survey <- read_csv(here('data', 'battery_choice_questions.csv'))
View(battery_survey)
View(battery_survey)
#battery_survey <- read_csv(here('data', 'battery_choice_questions.csv'))
battery_survey <- read_csv(here('data', 'battery_choice_questions_testing_zain.csv'))
View(battery_survey)
battery_survey1 <- read_csv(here('data', 'battery_choice_questions.csv'))
View(battery_survey1)
View(battery_survey)
runApp('survey_updated_pretest')
runApp('survey_updated_pretest')
# Load libraries
library(tidyverse)
library(cbcTools)
library(readr)
library(here)
library(logitr)
profiles_used <- cbc_profiles(
powertrain = c('Gasoline', 'Electric', 'Plug-in Hybrid', 'Hybrid'),
price = seq(0.8, 1.1, 0.1),
range = seq(50, 250, 25),
mileage = seq(20000, 60000, 5000),
my = seq(2015, 2023),
operating_cost = seq(3, 21, 3)
)
profiles_used
profiles_used_restricted <- profiles_used
profiles_used_restricted <- cbc_restrict(
profiles_used,
(powertrain == "Gasoline") & (operating_cost < 9),
(powertrain != "Gasoline") & (operating_cost >= 18)
)
profiles_used_restricted
# Check powertrain counts
profiles_used_restricted %>%
count(powertrain, operating_cost)
design_rand <- cbc_design(
profiles = profiles_used_restricted,
n_resp = 4000, # Number of respondents
n_alts = 3, # Number of alternatives per question
n_q = 6 # Number of questions per respondent
)
head(design_rand)
design_rand
duplicates <- design_rand[
duplicated(design_rand[c(
'respID',
'qID',
'powertrain',
'price',
'range',
'mileage',
'operating_cost'
)]),
]
duplicates
head(design_rand)
# Make conjoint surveys and simulate choice data using {cbcTools}
# Load libraries
library(tidyverse)
library(cbcTools)
library(readr)
library(here)
library(logitr)
# First, define the attributes and levels:
profiles_used <- cbc_profiles(
powertrain = c('Gasoline', 'Electric', 'Plug-in Hybrid', 'Hybrid'),
price = seq(0.8, 1.1, 0.1),
range = seq(50, 250, 25),
mileage = seq(20000, 60000, 5000),
my = seq(2015, 2023),
operating_cost = seq(3, 21, 3)
)
# Resrictions:
profiles_used_restricted <- profiles_used
profiles_used_restricted <- cbc_restrict(
profiles_used,
(powertrain == "Gasoline") & (operating_cost < 9),
(powertrain != "Gasoline") & (operating_cost >= 18)
)
# Check powertrain counts
profiles_used_restricted %>%
count(powertrain, operating_cost)
# Make a randomized full-factorial design:
design_rand <- cbc_design(
profiles = profiles_used_restricted,
n_resp = 4000, # Number of respondents
n_alts = 3, # Number of alternatives per question
n_q = 6 # Number of questions per respondent
)
head(design_rand)
# Make conjoint surveys and simulate choice data using {cbcTools}
# Load libraries
library(tidyverse)
library(cbcTools)
library(readr)
library(here)
library(logitr)
# First, define the attributes and levels:
profiles_used <- cbc_profiles(
powertrain = c('Gasoline', 'Electric', 'Plug-in Hybrid', 'Hybrid'),
price = seq(0.8, 1.1, 0.1),
range_bev = seq(50, 250, 25),
range_phev = seq(10, 40, 10),
mileage = seq(20000, 60000, 5000),
my = seq(2015, 2023),
operating_cost = seq(3, 21, 3)
)
# Resrictions:
profiles_used_restricted <- profiles_used
profiles_used_restricted <- cbc_restrict(
profiles_used,
(powertrain == "Gasoline") & (operating_cost < 9),
(powertrain != "Gasoline") & (operating_cost >= 18)
)
# Check powertrain counts
profiles_used_restricted %>%
count(powertrain, operating_cost)
# Make a randomized full-factorial design:
design_rand <- cbc_design(
profiles = profiles_used_restricted,
n_resp = 4000, # Number of respondents
n_alts = 3, # Number of alternatives per question
n_q = 6 # Number of questions per respondent
)
head(design_rand)
# Make conjoint surveys and simulate choice data using {cbcTools}
# Load libraries
library(tidyverse)
library(cbcTools)
library(readr)
library(here)
library(logitr)
# First, define the attributes and levels:
profiles_used <- cbc_profiles(
powertrain = c('Gasoline', 'Electric', 'Plug-in Hybrid', 'Hybrid'),
price = seq(0.8, 1.1, 0.1),
range_bev = seq(50, 250, 25),
range_phev = seq(10, 40, 10),
mileage = seq(20000, 60000, 5000),
my = seq(2015, 2023),
operating_cost = seq(3, 21, 3)
)
# Resrictions:
profiles_used_restricted <- profiles_used
profiles_used_restricted <- cbc_restrict(
profiles_used,
(powertrain == "Gasoline") & (operating_cost < 9),
(powertrain != "Gasoline") & (operating_cost >= 18),
(powertrain == "Plug-in Hybrid") & (range_phev > 40),
(powertrain == "Electric") & (range_bev < 50)
)
# Check powertrain counts
profiles_used_restricted %>%
count(powertrain, operating_cost)
design_rand <- cbc_design(
profiles = profiles_used_restricted,
n_resp = 4000, # Number of respondents
n_alts = 3, # Number of alternatives per question
n_q = 6 # Number of questions per respondent
)
head(design_rand)
design_rand %>%
count(powertrain)
design_rand <- design_rand %>%
cbc_decode()
design_rand
design_rand <- cbc_design(
profiles = profiles_used_restricted,
n_resp = 4000, # Number of respondents
n_alts = 3, # Number of alternatives per question
n_q = 6, # Number of questions per respondent
no_choice = TRUE
)
head(design_rand)
design_rand
design_rand %>%
cbc_decode()
head(design_rand)
design_rand %>%
count(starts_with('powertrain'))
design_rand %>%
select(starts_with('powertrain'))
design_rand
design_rand %>%
select(starts_with('power'))
design_rand %>%
tibble() %>%
select(starts_with('power'))
design_rand %>%
tibble() %>%
count(starts_with('power'))
design_rand %>%
tibble() %>%
select(starts_with('power'))
design_rand %>%
tibble() %>%
select(starts_with('power')) %>%
clean_names()
design_rand %>%
tibble() %>%
select(starts_with('power')) %>%
janitor::clean_names()
count(powertrain_electric, powertrain_plug_in_hybrid, powertrain_hybrid)
design_rand %>%
tibble() %>%
select(starts_with('power')) %>%
janitor::clean_names() %>%
count(powertrain_electric, powertrain_plug_in_hybrid, powertrain_hybrid)
18*3
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(powertrain_electric, powertrain_plug_in_hybrid, powertrain_hybrid, no_choice)
options(dplyr.width = Inf)
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(
powertrain_electric,
powertrain_plug_in_hybrid,
powertrain_hybrid,
no_choice
)
design_rand
design_rand$range_bev[design_rand$powertrainElectric != 1] <- 0
design_rand
# Make conjoint surveys and simulate choice data using {cbcTools}
# Load libraries
library(tidyverse)
library(cbcTools)
library(readr)
library(here)
library(logitr)
options(dplyr.width = Inf)
# First, define the attributes and levels:
profiles_used <- cbc_profiles(
powertrain = c('Gasoline', 'Electric', 'Plug-in Hybrid', 'Hybrid'),
price = seq(0.8, 1.1, 0.1),
range_bev = seq(50, 250, 25),
range_phev = seq(10, 40, 10),
mileage = seq(20000, 60000, 5000),
my = seq(2015, 2023),
operating_cost = seq(3, 21, 3)
)
# Resrictions:
profiles_used_restricted <- profiles_used
profiles_used_restricted <- cbc_restrict(
profiles_used,
(powertrain == "Gasoline") & (operating_cost < 9),
(powertrain != "Gasoline") & (operating_cost >= 18),
(powertrain == "Plug-in Hybrid") & (range_phev > 40),
(powertrain == "Electric") & (range_bev < 50)
)
# Make a randomized full-factorial design:
design_rand <- cbc_design(
profiles = profiles_used_restricted,
n_resp = 4000, # Number of respondents
n_alts = 3, # Number of alternatives per question
n_q = 6, # Number of questions per respondent
no_choice = TRUE
)
head(design_rand)
# Check that counts by powertrain are even
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(
powertrain_electric,
powertrain_plug_in_hybrid,
powertrain_hybrid,
no_choice
)
design_rand
head(design_rand$powertrainElectric != 1)
design_rand$range_bev[design_rand$powertrainElectric != 1] <- 0
design_rand
design_rand$range_phev[design_rand$`powertrainPlug-in Hybrid` != 1] <- 0
design_rand
# Make conjoint surveys and simulate choice data using {cbcTools}
# Load libraries
library(tidyverse)
library(cbcTools)
library(readr)
library(here)
library(logitr)
options(dplyr.width = Inf)
# First, define the attributes and levels:
profiles_used <- cbc_profiles(
powertrain = c('Gasoline', 'Electric', 'Plug-in Hybrid', 'Hybrid'),
price = seq(0.8, 1.1, 0.1),
range_bev = c(0, seq(50, 250, 25)),
range_phev = c(0, seq(10, 40, 10)),
mileage = seq(20000, 60000, 5000),
my = seq(2015, 2023),
operating_cost = seq(3, 21, 3)
)
# Resrictions:
profiles_used_restricted <- profiles_used
profiles_used_restricted <- cbc_restrict(
profiles_used,
(powertrain == "Gasoline") & (range_bev != 0),
(powertrain == "Hybrid") & (range_bev != 0),
(powertrain == "Gasoline") & (range_phev != 0),
(powertrain == "Hybrid") & (range_phev != 0),
(powertrain == "Gasoline") & (operating_cost < 9),
(powertrain != "Gasoline") & (operating_cost >= 18),
(powertrain == "Plug-in Hybrid") & (range_phev > 40),
(powertrain == "Plug-in Hybrid") & (range_phev == 0),
(powertrain == "Electric") & (range_bev < 50)
)
design_rand <- cbc_design(
profiles = profiles_used_restricted,
n_resp = 4000, # Number of respondents
n_alts = 3, # Number of alternatives per question
n_q = 6, # Number of questions per respondent
no_choice = TRUE
)
head(design_rand)
# Make conjoint surveys and simulate choice data using {cbcTools}
# Load libraries
library(tidyverse)
library(cbcTools)
library(readr)
library(here)
library(logitr)
options(dplyr.width = Inf)
# First, define the attributes and levels:
profiles_used <- cbc_profiles(
powertrain = c('Gasoline', 'Electric', 'Plug-in Hybrid', 'Hybrid'),
price = seq(0.8, 1.1, 0.1),
range_bev = c(0, seq(50, 250, 25)),
range_phev = c(0, seq(10, 40, 10)),
mileage = seq(20000, 60000, 5000),
my = seq(2015, 2023),
operating_cost = seq(3, 21, 3)
)
# Resrictions:
profiles_used_restricted <- profiles_used
profiles_used_restricted <- cbc_restrict(
profiles_used,
# BEV range restrictions
(powertrain == "Gasoline") & (range_bev != 0),
(powertrain == "Hybrid") & (range_bev != 0),
(powertrain == "Plug-in Hybrid") & (range_bev != 0),
(powertrain == "Electric") & (range_bev < 50),
# PHEV range restrictions
(powertrain == "Gasoline") & (range_phev != 0),
(powertrain == "Hybrid") & (range_phev != 0),
(powertrain == "Electric") & (range_phev != 0),
(powertrain == "Plug-in Hybrid") & (range_phev > 40),
(powertrain == "Plug-in Hybrid") & (range_phev == 0),
# Gas efficiency restrictions
(powertrain == "Gasoline") & (operating_cost < 9),
(powertrain != "Gasoline") & (operating_cost >= 18)
)
# Make a randomized full-factorial design:
design_rand <- cbc_design(
profiles = profiles_used_restricted,
n_resp = 4000, # Number of respondents
n_alts = 3, # Number of alternatives per question
n_q = 6, # Number of questions per respondent
no_choice = TRUE
)
head(design_rand)
# Check that counts by powertrain are even
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(
powertrain_electric,
powertrain_plug_in_hybrid,
powertrain_hybrid,
no_choice
)
