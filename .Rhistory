colnames(design_rand)
design_rand$range[design_rand$"powertrainBattery Electric"  !='1'] <- 0
View(design_rand)
duplicates <- design[duplicated(design[c('respID',
'qID',
'powertrain gas hybrid',
'powertrainPlug-in hybrid',
'powertrainBattery electric',
'price',
'range',
'mileage',
'make_year',
'operating_cost' )]), ]
duplicates <- design_rand[duplicated(design_rand[c('respID',
'qID',
'powertrain gas hybrid',
'powertrainPlug-in hybrid',
'powertrainBattery electric',
'price',
'range',
'mileage',
'make_year',
'operating_cost' )]), ]
duplicates <- design_rand[duplicated(design_rand[c('respID',
'qID',
'powertrainGas Hybrid',
'powertrainPlug-in Hybrid',
'powertrainBattery Electric',
'price',
'range',
'mileage',
'make_year',
'operating_cost' )]), ]
View(duplicates)
design <- design[!duplicated(design[c('respID',
'qID',
'powertrainGas Hybrid',
'powertrainPlug-in Hybrid',
'powertrainBattery Electric',
'price',
'range',
'mileage',
'make_year',
'operating_cost' )]), ]
design_rand <- design_rand[!duplicated(design_rand[c('respID',
'qID',
'powertrainGas Hybrid',
'powertrainPlug-in Hybrid',
'powertrainBattery Electric',
'price',
'range',
'mileage',
'make_year',
'operating_cost' )]), ]
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(
powertrain_battery_electric,
powertrain_plug_in_hybrid,
powertrain_gas_hybrid,
no_choice
)
cbc_inspect(design_rand)
choices <- cbc_choices(design_rand)
power <- cbc_power(choices)
power_basic <- cbc_power(
data = choices,
outcome = "choice",
pars = c(
# Specific dummy variables
"range_bev",
"powertrainElectric",
"powertrainPlug-in Hybrid",
"powertrainHybrid"
),
obsID = "obsID",
n_q = 6,
n_breaks = 10
)
# Chunk 1: setup
#| label: setup
#| include: false
knitr::opts_chunk$set(
warning = FALSE,
message = FALSE,
fig.path = "figs/",
fig.width = 7.252,
fig.height = 4,
comment = "#>",
fig.retina = 3
)
library(tidyverse)
library(cbcTools)
library(logitr)
library(here)
# Chunk 2
profiles <- cbc_profiles(
veh_mileage        = seq(1.5, 5, 0.5), # unit: 10000
veh_price          = seq(0.8, 1.1, 0.1), # unit: 20000
battery_refurbish  = c('original', 'cellreplace','packreplace'),
battery_range_year0 = seq(2, 3.6, 0.4), # unit: 100
battery_degradation = seq(1, 8, 1) # %
)
profiles
# Chunk 3
# Chunk 4
priors_fixed <- cbc_priors(
profiles = profiles,
veh_mileage          = -0.5,     # Each 10000 mile increase reduces utility by 0.5
veh_price            = -0.1,      # Each $20000 increase reduces utility by 0.1
battery_refurbish = c(-1.0, -0.5),   # Cell refurbishment least preferred
battery_range_year0  = 0.5,         # Each 100 mile of range adds utility by 0.5
battery_degradation  = -0.5         # Each 1% of degradation increases subtracts utility by 0.5
)
priors_fixed
# Chunk 5
priors_random_parameter <- cbc_priors(
profiles = profiles,
veh_mileage          = -0.5,     # Each 10000 mile increase reduces utility by 0.5
veh_price = -0.1, # Assume $1,000 price increase = -0.1 utility
battery_refurbish = rand_spec("n", c(-1.0, -0.5), c(0.1, 0.1)), # Reference = "original"
battery_range_year0 = 0.5,   # Each 100 mile of range adds utility by 0.5
battery_degradation = -0.5 # 1% increase in degradation = -1 utility
)
priors_random_parameter
# Chunk 6
# design_random <- cbc_design(
#   profiles = profiles,
#   # priors = priors_fixed,
#   method = "random", # randomized full-factorial design
#   n_resp   = 3000, # Number of respondents
#   n_alts   = 3,    # Number of alternatives per question
#   n_q      = 6    # Number of questions per respondent #6
# )
design_random_fixed_parameter <- cbc_design(
profiles = profiles,
priors = priors_fixed,
method = "random", # randomized full-factorial design
n_resp   = 3000, # Number of respondents
n_alts   = 3,    # Number of alternatives per question
n_q      = 6,    # Number of questions per respondent #6
remove_dominant = TRUE
)
design_random_random_parameter <- cbc_design(
profiles = profiles,
priors = priors_random_parameter,
method = "random", # randomized full-factorial design
n_resp   = 3000, # Number of respondents
n_alts   = 3,    # Number of alternatives per question
n_q      = 6,    # Number of questions per respondent #6
remove_dominant = TRUE
)
# Chunk 7
# design_shortcut <- cbc_design(
#   profiles = profiles,
#   method = "shortcut",
#   n_resp   = 3000, # Number of respondents
#   n_alts   = 3,    # Number of alternatives per question
#   n_q      = 6    # Number of questions per respondent #6
#
# )
#
# design_shortcut_fixed_parameter <- cbc_design(
#   profiles = profiles,
#   priors = priors_fixed,
#   method = "shortcut",
#   n_resp   = 3000, # Number of respondents
#   n_alts   = 3,    # Number of alternatives per question
#   n_q      = 6   # Number of questions per respondent #6
# )
## Code will not run
# design_shortcut_fixed_parameter_remove_dominant <- cbc_design(
#   profiles = profiles,
#   priors = priors_fixed,
#   method = "shortcut",
#   n_resp   = 3000, # Number of respondents
#   n_alts   = 3,    # Number of alternatives per question
#   n_q      = 6,   # Number of questions per respondent #6
#   remove_dominant = TRUE
# )
cbc_compare(
"Random_fixed_parameter" = design_random_fixed_parameter,
"Random_random_parameter" = design_random_random_parameter
# "Shortcut" = design_shortcut,
# "Shortcut_fixed_parameter" = design_shortcut_fixed_parameter
)
choices_random_fixed_parameter <- cbc_choices(design_random_fixed_parameter, priors = priors_fixed)
choices_random_random_parameter <- cbc_choices(design_random_random_parameter, priors = priors_random_parameter)
# choices_shortcut <- cbc_choices(design_shortcut)
# choices_shortcut_fixed_parameter <- cbc_choices(design_shortcut_fixed_parameter,priors = priors_fixed)
choices_cat <- cbc_decode(choices_random_fixed_parameter)
# Filter for the chosen rows only
choices_cat <- choices_cat[which(choices_cat$choice == 1), ]
# Counts of choices made for each attribute level
table(choices_cat$veh_mileage)
table(choices_cat$veh_price)
table(choices_cat$battery_refurbish)
table(choices_cat$battery_range_year0)
table(choices_cat$battery_degradation)
choices_cat <- cbc_decode(choices_random_random_parameter)
# Filter for the chosen rows only
choices_cat <- choices_cat[which(choices_cat$choice == 1), ]
# Counts of choices made for each attribute level
table(choices_cat$veh_mileage)
table(choices_cat$veh_price)
table(choices_cat$battery_refurbish)
table(choices_cat$battery_range_year0)
table(choices_cat$battery_degradation)
head(choices_cat)
# Chunk 1: setup
#| label: setup
#| include: false
knitr::opts_chunk$set(
warning = FALSE,
message = FALSE,
fig.path = "figs/",
fig.width = 7.252,
fig.height = 4,
comment = "#>",
fig.retina = 3
)
library(tidyverse)
library(cbcTools)
library(logitr)
library(here)
# Chunk 2
profiles <- cbc_profiles(
powertrain = c('Gasoline', 'Battery Electric', 'Plug-in Hybrid', 'Gas Hybrid'),
price = seq(0.8, 1.1, 0.1),
range = c(0, seq(0.5, 2.5, 0.25)), # unit: 100
mileage = seq(2, 6, 0.5), # unit: 10000
make_year = seq(2, 10),  # vehicle age: 2 -10
operating_cost = seq(3, 21, 3)
)
# Chunk 3
profiles_restricted <- cbc_restrict(
profiles,
# BEV range restrictions
(powertrain == "Battery Electric") & (range < 0.5),
# Gas efficiency restrictions
(powertrain == "Gasoline") & (operating_cost < 9),
(powertrain != "Gasoline") & (operating_cost >= 18)
)
# table(profiles_restricted$operating_cost)
# Chunk 4
priors_fixed_parameter <- cbc_priors(
profiles = profiles_restricted,
# powertrain: categorical (effects coded or dummy)
powertrain = c("Battery Electric" = -1.0, "Plug-in Hybrid" = 1.0,  "Gas Hybrid" = 0.5),
# price: scaled by 1,000s
price = -0.2,
# range bev: scaled by 100s → positive effect
range = 0.5,
# range phev: scaled by 100s → positive effect
mileage = -0.5,
# make_year: higher means older → negative effect
make_year = -0.2,
# operating cost: higher means worse → negative effect
operating_cost = -0.3,
no_choice = 0.5
)
# priors_fixed_parameter
# Chunk 5
# priors_random_parameter
# Chunk 6
design_rand <- cbc_design(
profiles = profiles_restricted,
method = 'random',
n_resp = 4000, # Number of respondents
n_alts = 3, # Number of alternatives per question
n_q = 6, # Number of questions per respondent
no_choice = TRUE,
priors = priors_fixed_parameter
)
# Chunk 7
cbc_inspect(design_rand)
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(
powertrain_battery_electric,
powertrain_plug_in_hybrid,
powertrain_gas_hybrid,
no_choice
)
table(design_rand$`powertrainBattery Electric`)
table(design_rand$`powertrainGas Hybrid`)
table(design_rand$`powertrainPlug-in Hybrid`)
table(design_rand$price)
table(design_rand$range)
table(design_rand$operating_cost)
table(design_rand$operating_cost)
design_rand$range[design_rand$"powertrainBattery Electric"  !='1'] <- 0
duplicates <- design_rand[duplicated(design_rand[c('respID',
'qID',
'powertrainGas Hybrid',
'powertrainPlug-in Hybrid',
'powertrainBattery Electric',
'price',
'range',
'mileage',
'make_year',
'operating_cost' )]), ]
design_rand <- design_rand[!duplicated(design_rand[c('respID',
'qID',
'powertrainGas Hybrid',
'powertrainPlug-in Hybrid',
'powertrainBattery Electric',
'price',
'range',
'mileage',
'make_year',
'operating_cost' )]), ]
design_rand
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(
powertrain_battery_electric,
powertrain_plug_in_hybrid,
powertrain_gas_hybrid,
no_choice
)
choices <- cbc_choices(design_rand)
choices
power <- cbc_power(choices)
logitr(
data = choices,
outcome = 'choice',
obsID = 'obsID',
pars = c('price', 'range', 'mileage')
)
model <- logitr(
data = choices,
outcome = 'choice',
obsID = 'obsID',
pars = c('price', 'range', 'mileage')
)
summary(model)
names(choices)
model <- logitr(
data = choices,
outcome = 'choice',
obsID = 'obsID',
pars = c(
'price', 'range', 'mileage', 'make_year', 'operating_cost',
"powertrainBattery Electric", "powertrainPlug-in Hybrid",
"powertrainGas Hybrid"
)
)
model <- logitr(
data = choices,
outcome = 'choice',
obsID = 'obsID',
pars = c(
'price', 'range', 'mileage', 'make_year', 'operating_cost'
#   "powertrainBattery Electric", "powertrainPlug-in Hybrid",
#   "powertrainGas Hybrid"
)
)
model <- logitr(
data = choices,
outcome = 'choice',
obsID = 'obsID',
pars = c(
'price', 'range', 'mileage', 'make_year', 'operating_cost',
"powertrainBattery Electric", "powertrainPlug-in Hybrid"
#   "powertrainGas Hybrid"
)
)
# Chunk 1: setup
#| label: setup
#| include: false
knitr::opts_chunk$set(
warning = FALSE,
message = FALSE,
fig.path = "figs/",
fig.width = 7.252,
fig.height = 4,
comment = "#>",
fig.retina = 3
)
library(tidyverse)
library(cbcTools)
library(logitr)
library(here)
# Chunk 2
profiles <- cbc_profiles(
powertrain = c('gas', 'bev', 'phev', 'hev'),
price = seq(0.8, 1.1, 0.1),
range = c(0, seq(0.5, 2.5, 0.25)), # unit: 100
mileage = seq(2, 6, 0.5), # unit: 10000
make_year = seq(2, 10),  # vehicle age: 2 -10
operating_cost = seq(3, 21, 3)
)
# Chunk 3
profiles_restricted <- cbc_restrict(
profiles,
# BEV range restrictions
(powertrain == "bev") & (range < 0.5),
# Gas efficiency restrictions
(powertrain == "gas") & (operating_cost < 9),
(powertrain != "gas") & (operating_cost >= 18)
)
# table(profiles_restricted$operating_cost)
# Chunk 4
priors_fixed_parameter <- cbc_priors(
profiles = profiles_restricted,
# powertrain: categorical (effects coded or dummy)
powertrain = c("bev" = -1.0, "phev" = -0.0,  "hev" = 0.5),
# price: scaled by 1,000s
price = -0.2,
# range bev: scaled by 100s → positive effect
range = 0.5,
# range phev: scaled by 100s → positive effect
mileage = -0.5,
# make_year: higher means older → negative effect
make_year = -0.2,
# operating cost: higher means worse → negative effect
operating_cost = -0.3,
no_choice = 0.5
)
# priors_fixed_parameter
# Chunk 5
# priors_random_parameter
# Chunk 6
design_rand <- cbc_design(
profiles = profiles_restricted,
method = 'random',
n_resp = 4000, # Number of respondents
n_alts = 3, # Number of alternatives per question
n_q = 6, # Number of questions per respondent
no_choice = TRUE,
priors = priors_fixed_parameter
)
# Chunk 7
cbc_inspect(design_rand)
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(
powertrain_battery_electric,
powertrain_plug_in_hybrid,
powertrain_gas_hybrid,
no_choice
)
cbc_inspect(design_rand)
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(
powertrainbev,
powertrainphev,
powertrainhev,
no_choice
)
table(design_rand$powertrainphev)
table(design_rand$powertrainhev)
table(design_rand$price)
table(design_rand$range)
table(design_rand$operating_cost)
design_rand$range[design_rand$"powertrainBattery Electric"  !='1'] <- 0
duplicates <- design_rand[duplicated(design_rand[c('respID',
'qID',
'powertrainhev',
'powertrainphev',
'powertrainbev',
'price',
'range',
'mileage',
'make_year',
'operating_cost' )]), ]
design_rand <- design_rand[!duplicated(design_rand[c('respID',
'qID',
'powertrainhev',
'powertrainphev',
'powertrainbev',
'price',
'range',
'mileage',
'make_year',
'operating_cost' )]), ]
design_rand %>%
tibble() %>%
select(starts_with('power'), no_choice) %>%
janitor::clean_names() %>%
count(
powertrainbev,
powertrainphev,
powertrainhev,
no_choice
)
choices <- cbc_choices(design_rand)
model <- logitr(
data = choices,
outcome = 'choice',
obsID = 'obsID',
pars = c(
'price', 'range', 'mileage', 'make_year', 'operating_cost',
'powertrainbev', 'powertrainphev', 'powertrainhev'
)
)
summary(model)
choices_priors <- cbc_choices(design_rand, priors)
power <- cbc_power(choices)
power
