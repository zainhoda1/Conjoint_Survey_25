nrow(data)
# Drop people who got screened out
data <- data %>%
filter(!is.na(current_page), current_page == "end") # 2025-08-07 18:38:21
nrow(data)
# Drop those who completed before the adjustments
data <- data %>%
filter(time_start > '2025-10-14 00:00:00') #2025-08-14 14:08:00 # 2025-08-06 18:38:21
nrow(data)
# Drop respondents that had a missing budget (somehow)
data <- data %>%
filter(!is.na(next_veh_budget))
nrow(data)
# Drop anyone who didn't complete all choice questions
data <- data %>%
filter(!is.na(vehicle_cbc_q1_button)) %>%
filter(!is.na(vehicle_cbc_q2_button)) %>%
filter(!is.na(vehicle_cbc_q3_button)) %>%
filter(!is.na(vehicle_cbc_q4_button)) %>%
filter(!is.na(vehicle_cbc_q5_button)) %>%
filter(!is.na(vehicle_cbc_q6_button))
nrow(data)
data <- data %>%
filter(vehicle_cbc_q0_button %in% c('option_1', 'option_4')) %>%
select(-vehicle_cbc_q0_button)
nrow(data)
# Drop anyone who answered the same question for all choice questions
data <- data %>%
mutate(
cbc_all_same = (vehicle_cbc_q1_button == vehicle_cbc_q2_button) &
(vehicle_cbc_q2_button == vehicle_cbc_q3_button) &
(vehicle_cbc_q3_button == vehicle_cbc_q4_button) &
(vehicle_cbc_q4_button == vehicle_cbc_q5_button) &
(vehicle_cbc_q5_button == vehicle_cbc_q6_button)
) %>%
filter(!cbc_all_same) %>%
select(-cbc_all_same)
nrow(data)
# Drop respondents who went too fast
data <- data %>%
mutate(
# Convert time to minutes
time_min_total = time_total / 60,
time_min_cbc = time_cbc_total / 60
)
# Look at summary of completion times
summary(data$time_min_total)
summary(data$time_min_cbc)
# Drop anyone who finished the choice question section in under 1 minute
# data <- data %>%
#   filter(time_min_cbc >= 1)
nrow(data)
# First convert the data to long format
choice_data <- data %>%
pivot_longer(
cols = vehicle_cbc_q1_button:vehicle_cbc_q6_button,
names_to = "qID",
values_to = "choice"
) %>%
# Convert the qID variable and choice column to a number
mutate(
qID = parse_number(qID),
choice = parse_number(choice),
vehicle_type = case_when(
next_veh_style == 'Car / sedan / hatchback' ~ 'car',
next_veh_style == 'SUV / crossover' ~ 'suv'
)
) %>%
select(-next_veh_style)
head(choice_data)
choice_data <- choice_data %>%
left_join(survey, by = c("vehicle_type", "respID", "qID"))
# Convert choice column to 1 or 0 based on if the alternative was chosen
choice_data <- choice_data %>%
mutate(
choice = ifelse(choice == altID, 1, 0),
price = price * next_veh_budget
)
head(choice_data)
# Remove bad respID
choice_data <- choice_data %>%
filter(respID != 3587)
data <- data %>%
filter(respID != 3587)
# Create new values for respID & obsID
nRespondents <- nrow(data)
nAlts <- max(survey$altID)
nQuestions <- max(survey$qID)
choice_data$respID <- rep(seq(nRespondents), each = nAlts * nQuestions)
choice_data$obsID <- rep(seq(nRespondents * nQuestions), each = nAlts)
# Reorder columns - it's nice to have the "ID" variables first
choice_data <- choice_data %>%
select(ends_with("ID"), "choice", everything())
head(choice_data)
# Save cleaned data for modeling
write_csv(
choice_data,
here(
"code files",
"old code",
"testing_initial_data_modeling",
"vehicle_choice_data.csv"
)
)
# Save cleaned data for modeling
write_csv(
choice_data,
here(
"code files",
"pilot",
"data",
"vehicle_choice_data.csv"
)
)
# Load libraries
library(fastDummies)
library(here)
library(lubridate)
library(tidyverse)
library(arrow)
# Change dplyr settings so I can view all columns
options(dplyr.widtkh = Inf)
data_raw <- read_csv(here(
"code files",
"pilot",
"data",
"survey_data.csv"
))
survey <- read_parquet(here(
"code files",
"Design folders",
"Design-10_14_25",
'design_battery.parquet'
))
# removing testing entries
data_raw <- data_raw %>%
filter(!is.na(psid), nchar(psid) >= 10)
# Compute time values for each page
data <- data_raw %>%
mutate(
# Compute time through whole survey
time_start = ymd_hms(time_start, tz = "UTC"),
time_end = ymd_hms(time_end, tz = "UTC"),
time_total = as.numeric(time_end - time_start, units = "secs"),
# Compute time through just the cbc questions
time_p_battery_pageQ1_button = ymd_hms(
time_p_battery_pageQ1_button,
tz = "UTC"
),
time_p_battery_pageQ6_button = ymd_hms(
time_p_battery_pageQ6_button,
tz = "UTC"
),
time_cbc_total = as.numeric(
time_p_battery_pageQ6_button - time_p_battery_pageQ1_button,
units = "secs"
)
) %>%
# Select important columns
select(
session_id,
time_start,
time_total,
time_cbc_total,
battery_respID,
next_veh_budget,
next_veh_style,
current_page,
starts_with("battery_cbc_q")
)
head(data)
nrow(data)
# Drop people who got screened out
data <- data %>%
filter(!is.na(current_page), current_page == "end") # 2025-08-07 18:38:21
nrow(data)
# Drop those who completed before the adjustments
data <- data %>%
filter(time_start > '2025-10-14 00:00:00') #2025-08-14 14:08:00 # 2025-08-06 18:38:21
nrow(data)
# Drop respondents that had a missing budget (somehow)
data <- data %>%
filter(!is.na(next_veh_budget))
nrow(data)
# Drop anyone who didn't complete all choice questions
data <- data %>%
filter(!is.na(battery_cbc_q1_button)) %>%
filter(!is.na(battery_cbc_q2_button)) %>%
filter(!is.na(battery_cbc_q3_button)) %>%
filter(!is.na(battery_cbc_q4_button)) %>%
filter(!is.na(battery_cbc_q5_button)) %>%
filter(!is.na(battery_cbc_q6_button))
nrow(data)
# Drop anyone who answered the same question for all choice questions
data <- data %>%
mutate(
cbc_all_same = (battery_cbc_q1_button == battery_cbc_q2_button) &
(battery_cbc_q2_button == battery_cbc_q3_button) &
(battery_cbc_q3_button == battery_cbc_q4_button) &
(battery_cbc_q4_button == battery_cbc_q5_button) &
(battery_cbc_q5_button == battery_cbc_q6_button)
) %>%
filter(!cbc_all_same) %>%
select(-cbc_all_same)
nrow(data)
# Drop respondents who went too fast
data <- data %>%
mutate(
# Convert time to minutes
time_min_total = time_total / 60,
time_min_cbc = time_cbc_total / 60
)
# Look at summary of completion times
summary(data$time_min_total)
summary(data$time_min_cbc)
# Drop anyone who finished the choice question section in under 1 minute
data <- data %>%
filter(time_min_cbc >= 0.5)
nrow(data)
data <- data %>%
distinct(battery_respID, .keep_all = TRUE)
# First convert the data to long format
choice_data <- data %>%
pivot_longer(
cols = battery_cbc_q1_button:battery_cbc_q6_button,
names_to = "qID",
values_to = "choice"
) %>%
# Convert the qID variable and choice column to a number
mutate(
qID = parse_number(qID),
choice = parse_number(choice),
vehicle_type = case_when(
next_veh_style == 'Car / sedan / hatchback' ~ 'car',
next_veh_style == 'SUV / crossover' ~ 'suv'
)
) %>%
select(-next_veh_style)
head(choice_data)
glimpse(choice_data)
glimpse(survey)
choice_data <- choice_data %>%
left_join(survey, by = c("battery_respID" = "respID", "qID"))
# Convert choice column to 1 or 0 based on if the alternative was chosen
choice_data <- choice_data %>%
mutate(
choice = ifelse(choice == altID, 1, 0),
veh_price = veh_price * next_veh_budget
)
glimpse(choice_data)
nrow(data)
# Create new values for respID & obsID
nRespondents <- nrow(data)
nAlts <- max(survey$altID)
nQuestions <- max(survey$qID)
choice_data$respID <- rep(seq(nRespondents), each = nAlts * nQuestions)
choice_data$obsID <- rep(seq(nRespondents * nQuestions), each = nAlts)
# Reorder columns - it's nice to have the "ID" variables first
choice_data <- choice_data %>%
select(ends_with("ID"), "choice", everything())
head(choice_data)
# Save cleaned data for modeling
write_csv(
choice_data,
here(
"code files",
"old code",
"testing_initial_data_modeling",
"battery_choice_data.csv"
)
)
# Save cleaned data for modeling
write_csv(
choice_data,
here(
"code files",
"pilot",
"data",
"battery_choice_data.csv"
)
)
# Load libraries
library(logitr)
library(tidyverse)
library(fastDummies)
library(cbcTools)
library(janitor)
library(here)
options(dplyr.width = Inf) # So you can see all of the columns
data <- read_csv(here(
"code files",
"pilot",
"data",
"vehicle_choice_data.csv"
))
head(data)
glimpse(data)
data <- data %>%
#select(price, mileage, age, operating_cost, )
mutate(
price = price / 10000, # 0.5-6
range_bev = range_bev / 100, # 0.5 - 2.5
range_phev = range_phev / 10, # 1 - 4
mileage = mileage * 10, # 2 - 6
age = age * 10, # 2 - 8
operating_cost = operating_cost / 10 # 0.3 - 2.5,
) %>%
select(-range, -operating_cost_text, -session_id, -vehicle_type)
# Dummy encode
data <- cbc_encode(data, coding = 'dummy') %>%
as.data.frame()
glimpse(data)
data %>%
count(choice, qID)
data %>%
count(no_choice, choice)
# Estimate the model
model <- logitr(
data = data,
outcome = "choice",
obsID = "obsID",
pars = c(
"price",
"mileage",
"age",
"operating_cost",
"range_bev",
"range_phev",
"powertrainbev",
"powertrainphev",
"powertrainhev",
"no_choice"
)
)
# View summary of results
summary(model)
# Check the 1st order condition: Is the gradient at the solution zero?
model$gradient
# 2nd order condition: Is the hessian negative definite?
# (If all the eigenvalues are negative, the hessian is negative definite)
eigen(model$hessian)$values
# Load libraries
library(logitr)
library(tidyverse)
library(fastDummies)
library(cbcTools)
library(janitor)
library(here)
options(dplyr.width = Inf) # So you can see all of the columns
data <- read_csv(here(
"code files",
"pilot",
"data",
"battery_choice_data.csv"
))
glimpse(data)
data <- data %>%
mutate(
veh_mileage = veh_mileage / 10000, #3 - 6
veh_price = veh_price / 10000, # 0.5 - 6
battery_range_year0 = battery_range_year0 / 100, # 1-3
battery_range_year3 = battery_range_year3 / 100, # 1-3
battery_range_year8 = battery_range_year8 / 100, # 0.5 - 2
battery_degradation = (battery_degradation * 10)
) %>%
select(
-starts_with("battery_health"),
-starts_with("time"),
-session_id,
-vehicle_type,
-battery_condition
)
# Dummy encode
data <- cbc_encode(
data,
coding = 'dummy',
ref_levels = list(battery_refurbish = 'original')
) %>%
as.data.frame() %>%
clean_names()
glimpse(data)
# Estimate the model
model1 <- logitr(
data = data,
outcome = "choice",
obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
"battery_range_year3",
"battery_range_year8",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
)
)
# View summary of results
summary(model1)
# Check the 1st order condition: Is the gradient at the solution zero?
model1$gradient
# 2nd order condition: Is the hessian negative definite?
# (If all the eigenvalues are negative, the hessian is negative definite)
eigen(model$hessian)$values
# 2nd order condition: Is the hessian negative definite?
# (If all the eigenvalues are negative, the hessian is negative definite)
eigen(model1$hessian)$values
# Estimate the model
model2 <- logitr(
data = data,
outcome = "choice",
obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
"battery_range_year0",
"battery_degradation",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
)
)
# View summary of results
summary(model2)
# Check the 1st order condition: Is the gradient at the solution zero?
model$gradient
# Estimate multinomial logit (MNL) models
# Load libraries
library(logitr)
library(tidyverse)
library(fastDummies)
library(cbcTools)
library(janitor)
library(here)
options(dplyr.width = Inf) # So you can see all of the columns
# -----------------------------------------------------------------------------
# Load the data set:
data <- read_csv(here(
"code files",
"pilot",
"data",
"battery_choice_data.csv"
))
#head(data)
glimpse(data)
data <- data %>%
mutate(
veh_mileage = veh_mileage / 10000, #3 - 6
veh_price = veh_price / 10000, # 0.5 - 6
battery_range_year0 = battery_range_year0 / 100, # 1-3
battery_range_year3 = battery_range_year3 / 100, # 1-3
battery_range_year8 = battery_range_year8 / 100, # 0.5 - 2
battery_degradation = (battery_degradation * 10)
) %>%
select(
-starts_with("battery_health"),
-starts_with("time"),
-session_id,
-vehicle_type,
-battery_condition
)
# Dummy encode
data <- cbc_encode(
data,
coding = 'dummy',
ref_levels = list(battery_refurbish = 'original')
) %>%
as.data.frame() %>%
clean_names()
# Estimate MNL model
# First create some dummy coded variables for categorical variables
#data <- dummy_cols(data, c('battery_refurbish', 'degradation_high'))
# Clean up names of created variables
glimpse(data)
# Estimate the model
model1 <- logitr(
data = data,
outcome = "choice",
obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
"battery_range_year3",
"battery_range_year8",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
)
)
# View summary of results
summary(model1)
# Check the 1st order condition: Is the gradient at the solution zero?
model1$gradient
# 2nd order condition: Is the hessian negative definite?
# (If all the eigenvalues are negative, the hessian is negative definite)
eigen(model1$hessian)$values
# Estimate the model
model2 <- logitr(
data = data,
outcome = "choice",
obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
"battery_range_year0",
"battery_degradation",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
)
)
# View summary of results
summary(model2)
