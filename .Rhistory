<<<<<<< HEAD
=======
obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
#### ranges are highly correlated, so only include one year.
#### Keeping year8 generates higher R2
# "battery_range_year3",
"battery_range_year8",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
)
)
# View summary of results
summary(model1)
# Check the 1st order condition: Is the gradient at the solution zero?
model1$gradient
# 2nd order condition: Is the hessian negative definite?
# (If all the eigenvalues are negative, the hessian is negative definite)
eigen(model1$hessian)$values
# Estimate the model
model2 <- logitr(
data = data,
outcome = "choice",
obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
"battery_range_year0",
"battery_degradation",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
)
)
# View summary of results
summary(model2)
n_distinct(data$session_id)
source(here::here('code', 'setup.R'))
data <- read_csv(here(
"data",
"main",
"battery_choice_data.csv"
))
n_distinct(data$session_id)
glimpse(data)
data <- data %>%
mutate(
veh_mileage = veh_mileage / 10000, #3 - 6
veh_price = veh_price / 10000, # 0.5 - 6
battery_range_year0 = battery_range_year0 / 100, # 1-3
battery_range_year3 = battery_range_year3 / 100, # 1-3
battery_range_year8 = battery_range_year8 / 100, # 0.5 - 2
battery_degradation = (battery_degradation * 10)
) %>%
select(
-starts_with("battery_health"),
-starts_with("time"),
-session_id,
-vehicle_type,
-battery_condition
)
source(here::here('code', 'setup.R'))
pilot_start <- ymd_hms('2025-10-14 21:00:00')
pilot_end <- ymd_hms('2025-10-21 16:00:00')
# Connect to database
#### surveydown::sd_db_config()
db <- sd_db_connect()
# original db
data_raw <- sd_get_data(db)
# removing testing entries
data_raw <- data_raw %>%
filter(!is.na(psid), nchar(psid) >= 10)
# Some special variables:
# session_id = a unique ID for the Run - should be the same across all surveys
# time_start = time stamp when survey was started
# time_end   = time stamp when survey ended
# time_p_*** = Time page *** was reached
# time_q_*** = Time question *** was last answered
# Compute time values for each page
data <- data_raw %>%
mutate(
# Compute time through whole survey
time_start = ymd_hms(time_start, tz = "UTC"),
time_end = ymd_hms(time_end, tz = "UTC"),
time_total = as.numeric(time_end - time_start, units = "secs"),
# Compute time through just the cbc questions
## Vehicle
time_p_vehicle_pageQ1_button = ymd_hms(
time_p_vehicle_pageQ1_button,
tz = "UTC"
),
time_p_vehicle_pageQ6_button = ymd_hms(
time_p_vehicle_pageQ6_button,
tz = "UTC"
),
time_vehicle_cbc_total = as.numeric(
time_p_vehicle_pageQ6_button - time_p_vehicle_pageQ1_button,
units = "secs"
),
## Battery
time_p_battery_pageQ1_button = ymd_hms(
time_p_battery_pageQ1_button,
tz = "UTC"
),
time_p_battery_pageQ6_button = ymd_hms(
time_p_battery_pageQ6_button,
tz = "UTC"
),
time_battery_cbc_total = as.numeric(
time_p_battery_pageQ6_button - time_p_battery_pageQ1_button,
units = "secs"
),
time_min_total = time_total / 60,
time_min_vehicle_cbc = time_vehicle_cbc_total / 60,
time_min_battery_cbc = time_battery_cbc_total / 60
)
data <- data %>%
# Bot
filter(is.na(attention_check_toyota)) %>%
# Survey question removed
select(
!c(
attention_check_toyota,
attitudes_1_a,
attitudes_1_b,
attitudes_2_a,
attitudes_2_b,
battery_attribute
)
) %>%
# Drop people who got screened out
filter(!is.na(current_page), current_page == "end") %>%
select(-current_page) %>%
# Drop those who completed before the adjustments
filter(time_start > pilot_end) %>%
#filter(time_start <= pilot_end) %>%
# Drop respondents that had a missing budget (somehow)
filter(!is.na(next_veh_budget))
#n_distinct(data$session_id)  # 98
write_csv(
data,
here(
"data",
"main",
"survey_data.csv"
)
)
source(here::here('code', 'setup.R'))
# Import raw data
data_raw <- read_csv(here(
"data",
"main",
"survey_data.csv"
))
# Read in choice questions and join it to the choice_data
survey <- read_parquet(here(
"data",
"doe",
"design-10-14-25",
'design_vehicle.parquet'
))
# Compute time values for each page
data <- data_raw %>%
# Select important columns
select(
session_id,
time_start,
time_min_total,
time_min_vehicle_cbc,
respID,
next_veh_budget,
next_veh_style,
starts_with("vehicle_cbc_q")
)
# Drop anyone who didn't complete all choice questions
data <- data %>%
filter(!is.na(vehicle_cbc_q1_button)) %>%
filter(!is.na(vehicle_cbc_q2_button)) %>%
filter(!is.na(vehicle_cbc_q3_button)) %>%
filter(!is.na(vehicle_cbc_q4_button)) %>%
filter(!is.na(vehicle_cbc_q5_button)) %>%
filter(!is.na(vehicle_cbc_q6_button))
nrow(data)
# Drop anyone who got the demo question wrong:
data <- data %>%
filter(vehicle_cbc_q0_button %in% c('option_1', 'option_4')) %>%
select(-vehicle_cbc_q0_button)
nrow(data)
# Drop anyone who answered the same question for all choice questions
data <- data %>%
mutate(
cbc_all_same = (vehicle_cbc_q1_button == vehicle_cbc_q2_button) &
(vehicle_cbc_q2_button == vehicle_cbc_q3_button) &
(vehicle_cbc_q3_button == vehicle_cbc_q4_button) &
(vehicle_cbc_q4_button == vehicle_cbc_q5_button) &
(vehicle_cbc_q5_button == vehicle_cbc_q6_button)
) %>%
filter(!cbc_all_same) %>%
select(-cbc_all_same)
nrow(data)
# Drop respondents who went too fast
# Look at summary of completion times
summary(data$time_min_total)
summary(data$time_min_vehicle_cbc)
# Drop anyone who finished the choice question section in under 1 minute
data <- data %>%
filter(time_min_vehicle_cbc >= 0.5) %>%
# dropping non-unique respID (keeping first one)
distinct(respID, .keep_all = TRUE)
nrow(data)
# Create choice data ---------
# First convert the data to long format
choice_data <- data %>%
pivot_longer(
cols = vehicle_cbc_q1_button:vehicle_cbc_q6_button,
names_to = "qID",
values_to = "choice"
) %>%
# Convert the qID variable and choice column to a number
mutate(
qID = parse_number(qID),
choice = parse_number(choice),
vehicle_type = case_when(
next_veh_style == 'Car / sedan / hatchback' ~ 'car',
next_veh_style == 'SUV / crossover' ~ 'suv'
)
) %>%
select(-next_veh_style)
head(choice_data)
choice_data <- choice_data %>%
left_join(survey, by = c("vehicle_type", "respID", "qID"))
# Convert choice column to 1 or 0 based on if the alternative was chosen
choice_data <- choice_data %>%
mutate(
choice = ifelse(choice == altID, 1, 0),
price = price * next_veh_budget
)
head(choice_data)
# Remove bad respID
choice_data <- choice_data %>%
filter(respID != 3587)
data <- data %>%
filter(respID != 3587)
# Create new values for respID & obsID
nRespondents <- nrow(data)
nAlts <- max(survey$altID)
nQuestions <- max(survey$qID)
choice_data$respID <- rep(seq(nRespondents), each = nAlts * nQuestions)
choice_data$obsID <- rep(seq(nRespondents * nQuestions), each = nAlts)
# Reorder columns - it's nice to have the "ID" variables first
choice_data <- choice_data %>%
select(ends_with("ID"), "choice", everything())
head(choice_data)
# Save cleaned data for modeling
write_csv(
choice_data,
here(
"data",
"main",
"vehicle_choice_data.csv"
)
)
source(here::here('code', 'setup.R'))
# Import raw data
data_raw <- read_csv(here(
"data",
"main",
"survey_data.csv"
))
# Read in choice questions and join it to the choice_data
survey <- read_parquet(here(
"data",
"doe",
"design-10-14-25",
'design_battery.parquet'
))
# Format and join the three surveys -------
# Compute time values for each page
data <- data_raw %>%
# Select important columns
select(
session_id,
time_start,
time_min_total,
time_min_battery_cbc,
battery_respID,
next_veh_budget,
next_veh_style,
starts_with("battery_cbc_q"),
-battery_cbc_q0_button
) %>%
rename(respID = battery_respID)  #changed battery_respID to just respID for ease of use
glimpse(data)
# Drop respondents who went too fast
# Look at summary of completion times
summary(data$time_min_total)
summary(data$time_min_battery_cbc)
data <- data %>%
# Drop anyone who finished the choice question section in under 30 second
filter(time_min_battery_cbc >= 0.5) %>%
# dropping non-unique respID (keeping first one)
distinct(respID, .keep_all = TRUE)
# Drop anyone who didn't complete all choice questions
data <- data %>%
filter(!is.na(battery_cbc_q1_button)) %>%
filter(!is.na(battery_cbc_q2_button)) %>%
filter(!is.na(battery_cbc_q3_button)) %>%
filter(!is.na(battery_cbc_q4_button)) %>%
filter(!is.na(battery_cbc_q5_button)) %>%
filter(!is.na(battery_cbc_q6_button))
nrow(data)
# Drop anyone who answered the same question for all choice questions
data <- data %>%
mutate(
cbc_all_same = (battery_cbc_q1_button == battery_cbc_q2_button) &
(battery_cbc_q2_button == battery_cbc_q3_button) &
(battery_cbc_q3_button == battery_cbc_q4_button) &
(battery_cbc_q4_button == battery_cbc_q5_button) &
(battery_cbc_q5_button == battery_cbc_q6_button)
) %>%
filter(!cbc_all_same) %>%
select(-cbc_all_same)
nrow(data)
# Create choice data ---------
# First convert the data to long format
choice_data <- data %>%
pivot_longer(
cols = battery_cbc_q1_button:battery_cbc_q6_button,
names_to = "qID",
values_to = "choice"
) %>%
>>>>>>> 950876ce11dd302ab459e82479e7a12ce6dde129
# Convert the qID variable and choice column to a number
mutate(
qID = parse_number(qID),
choice = parse_number(choice),
vehicle_type = case_when(
next_veh_style == 'Car / sedan / hatchback' ~ 'car',
next_veh_style == 'SUV / crossover' ~ 'suv'
)
) %>%
select(-next_veh_style)
head(choice_data)
glimpse(choice_data)
glimpse(survey)
choice_data <- choice_data %>%
left_join(survey, by = c("respID", "qID"))
# Convert choice column to 1 or 0 based on if the alternative was chosen
choice_data <- choice_data %>%
mutate(
choice = ifelse(choice == altID, 1, 0),
veh_price = veh_price * next_veh_budget
)
glimpse(choice_data)
nrow(data)
# Create new values for respID & obsID
nRespondents <- nrow(data)
nAlts <- max(survey$altID)
nQuestions <- max(survey$qID)
choice_data$respID <- rep(seq(nRespondents), each = nAlts * nQuestions)
choice_data$obsID <- rep(seq(nRespondents * nQuestions), each = nAlts)
# Reorder columns - it's nice to have the "ID" variables first
choice_data <- choice_data %>%
select(ends_with("ID"), "choice", everything())
head(choice_data)
# Save cleaned data for modeling
write_csv(
choice_data,
here(
"data",
"main",
"battery_choice_data.csv"
)
)
source(here::here('code', 'setup.R'))
<<<<<<< HEAD
data <- read_csv(here(
"data",
"pilot",
"battery_choice_data.csv"
=======
# Load libraries
library(fastDummies)
library(here)
library(lubridate)
library(tidyverse)
library(arrow)
# Change dplyr settings so I can view all columns
options(dplyr.widtkh = Inf)
# Import raw data
data_raw <- read_csv(here(
"code files",
"pilot",
"data",
"survey_data.csv"
>>>>>>> Stashed changes
))
# Read in choice questions and join it to the choice_data
survey <- read_parquet(here(
"code files",
"Design folders",
"Design-10_14_25",
'design_vehicle.parquet'
))
# Compute time values for each page
data <- data_raw %>%
# Select important columns
select(
session_id,
time_start,
time_total,
time_min_vehicle_cbc,
respID,
next_veh_budget,
next_veh_style,
starts_with("vehicle_cbc_q")
)
# Drop anyone who didn't complete all choice questions
data <- data %>%
filter(!is.na(vehicle_cbc_q1_button)) %>%
filter(!is.na(vehicle_cbc_q2_button)) %>%
filter(!is.na(vehicle_cbc_q3_button)) %>%
filter(!is.na(vehicle_cbc_q4_button)) %>%
filter(!is.na(vehicle_cbc_q5_button)) %>%
filter(!is.na(vehicle_cbc_q6_button))
nrow(data)
# Drop anyone who got the demo question wrong:
data <- data %>%
filter(vehicle_cbc_q0_button %in% c('option_1', 'option_4')) %>%
select(-vehicle_cbc_q0_button)
nrow(data)
# Drop anyone who answered the same question for all choice questions
data <- data %>%
mutate(
cbc_all_same = (vehicle_cbc_q1_button == vehicle_cbc_q2_button) &
(vehicle_cbc_q2_button == vehicle_cbc_q3_button) &
(vehicle_cbc_q3_button == vehicle_cbc_q4_button) &
(vehicle_cbc_q4_button == vehicle_cbc_q5_button) &
(vehicle_cbc_q5_button == vehicle_cbc_q6_button)
) %>%
filter(!cbc_all_same) %>%
select(-cbc_all_same)
nrow(data)
# Drop respondents who went too fast
# Look at summary of completion times
summary(data$time_min_total)
summary(data$time_min_cbc)
# Drop anyone who finished the choice question section in under 1 minute
data <- data %>%
filter(time_min_vehicle_cbc >= 1) %>%
# dropping non-unique respID (keeping first one)
distinct(respID, .keep_all = TRUE)
nrow(data)
# Create choice data ---------
# First convert the data to long format
choice_data <- data %>%
pivot_longer(
cols = vehicle_cbc_q1_button:vehicle_cbc_q6_button,
names_to = "qID",
values_to = "choice"
) %>%
<<<<<<< Updated upstream
as.data.frame() %>%
clean_names()
glimpse(data)
# Estimate the model
model1 <- logitr(
data = data,
outcome = "choice",
obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
#### ranges are highly correlated, so only include one year.
#### Keeping year8 generates higher R2
# "battery_range_year3",
"battery_range_year8",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
=======
# Convert the qID variable and choice column to a number
mutate(
qID = parse_number(qID),
choice = parse_number(choice),
vehicle_type = case_when(
next_veh_style == 'Car / sedan / hatchback' ~ 'car',
next_veh_style == 'SUV / crossover' ~ 'suv'
>>>>>>> Stashed changes
)
) %>%
select(-next_veh_style)
head(choice_data)
# temp_survey <- survey %>%
#   filter(respID == 2859,
#          vehicle_type == 'car')
#
# temp_data <- data_raw %>%
#   filter(respID == 2859 ,
#     next_veh_style == 'Car / sedan / hatchback')
#
# temp_choice <- choice_data %>%
#   filter(respID == 2859,
#          vehicle_type == 'car')
#
# c1 <- choice_data
choice_data <- choice_data %>%
left_join(survey, by = c("vehicle_type", "respID", "qID"))
# temp_choice1 <- choice_data %>%
#   filter(respID == 2859,
#          vehicle_type == 'car')
# Convert choice column to 1 or 0 based on if the alternative was chosen
choice_data <- choice_data %>%
mutate(
choice = ifelse(choice == altID, 1, 0),
price = price * next_veh_budget
)
<<<<<<< Updated upstream
# View summary of results
summary(model1)
# Check the 1st order condition: Is the gradient at the solution zero?
model1$gradient
# 2nd order condition: Is the hessian negative definite?
# (If all the eigenvalues are negative, the hessian is negative definite)
eigen(model1$hessian)$values
# Estimate the model
model2 <- logitr(
data = data,
outcome = "choice",
obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
"battery_range_year0",
"battery_degradation",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
)
)
# View summary of results
summary(model2)
source(here::here('code', 'setup.R'))
=======
>>>>>>> 950876ce11dd302ab459e82479e7a12ce6dde129
# --------------------------------------------------------------------------
# Load the data set:
data <- read_csv(here(
"data",
"main",
"vehicle_choice_data.csv"
))
head(data)
#n_distinct(data$session_id)  #334
glimpse(data)
data <- data %>%
mutate(
price = price / 10000, # 0.5-6
range_bev = range_bev / 100, # 0.5 - 2.5
range_phev = range_phev / 10, # 1 - 4
mileage = mileage * 10, # 2 - 6
age = age * 10, # 2 - 8
operating_cost = operating_cost / 10 # 0.3 - 2.5,
) %>%
select(-range, -operating_cost_text, -session_id, -vehicle_type)
# Dummy encode
data <- cbc_encode(data, coding = 'dummy', ref_levels = list(powertrain='gas')) %>%
as.data.frame()
glimpse(data)
# Estimate MNL model
# First create some dummy coded variables for categorical variables
#data <- dummy_cols(data, c('powertrain'))
data %>%
count(choice, qID)
data %>%
count(no_choice, choice)
# Estimate the model
model <- logitr(
data = data,
outcome = "choice",
obsID = "obsID",
pars = c(
"price",
"mileage",
"age",
"operating_cost",
"range_bev",
"range_phev",
"powertrainbev",
"powertrainphev",
"powertrainhev",
"no_choice"
)
)
# View summary of results
summary(model)
# Check the 1st order condition: Is the gradient at the solution zero?
model$gradient
# 2nd order condition: Is the hessian negative definite?
# (If all the eigenvalues are negative, the hessian is negative definite)
eigen(model$hessian)$values
source(here::here('code', 'setup.R'))
# -----------------------------------------------------------------------------
# Load the data set:
data <- read_csv(here(
"data",
"main",
"battery_choice_data.csv"
))
#head(data)
#n_distinct(data$session_id)  #373
glimpse(data)
data <- data %>%
mutate(
veh_mileage = veh_mileage / 10000, #3 - 6
veh_price = veh_price / 10000, # 0.5 - 6
battery_range_year0 = battery_range_year0 / 100, # 1-3
battery_range_year3 = battery_range_year3 / 100, # 1-3
battery_range_year8 = battery_range_year8 / 100, # 0.5 - 2
battery_degradation = (battery_degradation * 10)
) %>%
select(
-starts_with("battery_health"),
-starts_with("time"),
-session_id,
-vehicle_type,
-battery_condition
)
# Dummy encode
data <- cbc_encode(
data,
coding = 'dummy',
ref_levels = list(battery_refurbish = 'original')
) %>%
as.data.frame() %>%
clean_names()
# Estimate MNL model
# First create some dummy coded variables for categorical variables
#data <- dummy_cols(data, c('battery_refurbish', 'degradation_high'))
# Clean up names of created variables
glimpse(data)
# Estimate the model
model1 <- logitr(
data = data,
outcome = "choice",
obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
#### ranges are highly correlated, so only include one year.
#### Keeping year8 generates higher R2
# "battery_range_year3",
"battery_range_year8",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
<<<<<<< HEAD
=======
head(choice_data)
# Remove bad respID
choice_data <- choice_data %>%
filter(respID != 3587)
data <- data %>%
filter(respID != 3587)
# Create new values for respID & obsID
nRespondents <- nrow(data)
nAlts <- max(survey$altID)
nQuestions <- max(survey$qID)
choice_data$respID <- rep(seq(nRespondents), each = nAlts * nQuestions)
choice_data$obsID <- rep(seq(nRespondents * nQuestions), each = nAlts)
# Reorder columns - it's nice to have the "ID" variables first
choice_data <- choice_data %>%
select(ends_with("ID"), "choice", everything())
head(choice_data)
# Save cleaned data for modeling
write_csv(
choice_data,
here(
"code files",
"pilot",
"data",
"vehicle_choice_data.csv"
>>>>>>> Stashed changes
)
)
source(here::here('code', 'setup.R'))
data <- read_csv(here(
"data",
"pilot",
"survey_data.csv"
))
source(here::here('code', 'setup.R'))
data <- read_csv(here(
"data",
"pilot",
"survey_data.csv"
))
data <- read_csv(here(
"data",
"pilot",
"survey_data.csv"
))
data <- data %>%
mutate(
age_num = 2025 - birth_year,
gender_cate = case_when(
gender == "prefer_not_answer" ~ "prefer_not_answer",
gender %notin% c("male", "female") ~ "other",
T ~ gender
),
ethnicity_cate = case_when(
ethnicity == "no" ~ "non-hispanic",
T ~ "hispanic"
),
race_cate = case_when(
race == "white" ~ "white_only",
race == "african_american" ~ "african_american_only",
T ~ "other"
),
education_cate = case_when(
education == "prefer_not_answer" ~ "prefer_not_answer",
education %in% c("below_high_school", "high_school") ~ "high_school",
education %in%
c("college_less", "college_more", "technical") ~ "some_college",
education %in% c("bachelor", "Postgraduate courses") ~ "bachelor",
T ~ "graduate"
),
student_cate = case_when(
str_detect(employment, "student") ~ "student",
employment == "prefer_not_answer" ~ "prefer_not_answer",
T ~ "non-student"
),
employment_cate = case_when(
employment == "prefer_not_answer" ~ "prefer_not_answer",
str_detect(employment, "full_time") ~ "full_time",
str_detect(employment, "part_time") ~ "part_time",
T ~ "not_employed"
),
hhincome_num = as.numeric(hh_income),
hhsize_num = case_when(
hh_size == "more_than_5" ~ 6,
T ~ as.numeric(hh_size)
),
hhtenure_cate = case_when(
housing_tenure %in% c("own", "rent") ~ housing_tenure,
housing_tenure == "do_not_know" ~ "prefer_not_answer",
T ~ "other"
),
hhtype_cate = case_when(
housing_type %in% c("sf_detached", "sf_attached") ~ housing_type,
str_detect(housing_type, "apart") ~ "apart",
T ~ "other"
)
) %>%
mutate(final_weights = 1)
# ----Attitudes----
## ----BEV (factor analysis)----
### Explortory Factor analysis
### (http://www.di.fc.ul.pt/~jpn/r/factoranalysis/factoranalysis.html)
att <- data %>%
# filter(attitudes_2_a_attention_check_agree=="strongly_agree")%>%
select(!attitudes_2_a_attention_check_agree) %>%
select(
session_id,
attitudes_1_a_ev_norm:attitudes_2_a_ev_battery_function,
-(contains("battery"))
) %>%
mutate(across(
starts_with("attitudes_"),
~ case_match(
.,
"strongly_disagree" ~ 1,
"somewhat_disagree" ~ 2,
"neutral" ~ 3,
"somewhat_agree" ~ 4,
"strongly_agree" ~ 5,
.default = NA_integer_
)
))
# summary(att)
att <- as.data.frame(att[complete.cases(att), ])
fit <- factanal(
att[, c(2:ncol(att))],
2,
rotation = "promax",
score = "Bartlett"
)
l <- fit$loadings
# l<-fit_oblimin$loadings
l.table <- data.frame(matrix(
as.numeric(l),
attributes(l)$dim,
dimnames = attributes(l)$dimnames
))
l.table <- cbind(row.names(l.table), l.table)
######### Factor Loading
scores <- data.frame(fit$scores)
att_a_FC <- cbind(att, scores) %>%
select(session_id, Factor1, Factor2)
colnames(att_a_FC) <- c("session_id", "FA_EV_benefit", "FA_EV_anxiety")
data$FA_EV_benefit <- NULL
data$FA_EV_anxiety <- NULL
data <- data %>%
merge(att_a_FC, by = "session_id", all.x = T)
## ----Other----
data <- data %>%
mutate(
ATT_EVB_environment = attitudes_2_a_ev_battery_environment,
ATT_EVB_function = attitudes_2_a_ev_battery_function,
ATT_techsavvy = attitudes_2_b_tech_savvy,
ATT_risktaker = attitudes_2_b_risk_taker,
ATT_climate = climate_change,
ATT_political = political_view,
ATT_voting = party_voting
)
# ----Knowledge----
data <- data %>%
mutate(
knowledge_gas = case_when(
run_on_gasoline == "hev, phev" ~ 2,
str_detect(run_on_gasoline, "hev") |
str_detect(run_on_gasoline, "phev") ~ 1,
T ~ 0
),
knowledge_plugin = case_when(
plugged_in == "phev, bev" ~ 2,
str_detect(plugged_in, "bev") | str_detect(run_on_gasoline, "phev") ~ 1,
T ~ 0
),
knowledge_ev = case_when(know_electric_vehicle == "yes" ~ 1, T ~ 0), # need more data cleaning
knowledge_subsidy = case_when(max_subsidy == "7500" ~ 1, T ~ 0)
)
# ----Vehicle Attributes----
data <- data %>%
mutate(
Veh_hh_count = household_veh_count,
Veh_hh_fuel = case_when(
household_veh_fuel == "other" ~ "other",
household_veh_fuel == "icev" ~ "icev_only",
str_detect(household_veh_fuel, "icev") ~ "ev_mix",
T ~ "ev_only"
),
EV_charger = charger_access,
EV_neighbor = neighbor_ev_info,
Veh_primary_fuel = case_when(
is.na(primary_veh_fuel) ~ household_veh_fuel,
T ~ primary_veh_fuel
=======
>>>>>>> 950876ce11dd302ab459e82479e7a12ce6dde129
)
)
# View summary of results
summary(model1)
# Check the 1st order condition: Is the gradient at the solution zero?
model1$gradient
# 2nd order condition: Is the hessian negative definite?
# (If all the eigenvalues are negative, the hessian is negative definite)
eigen(model1$hessian)$values
# Estimate the model
model2 <- logitr(
data = data,
outcome = "choice",
obsID = "obs_id",
pars = c(
"veh_mileage",
"veh_price",
"battery_range_year0",
"battery_degradation",
"battery_refurbishpackreplace",
"battery_refurbishcellreplace",
"no_choice"
)
)
# View summary of results
summary(model2)
